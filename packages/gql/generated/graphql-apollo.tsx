import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** Date with time (isoformat) */
  DateTime: any;
  /** A 32-byte scalar value. */
  Hash32: any;
  /** The `Long` scalar type represents a 64 bit integer. */
  Long: any;
  /** A Secp256k1 public key. */
  PublicKey: any;
};

/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type Account = Entity & LightsparkNodeOwner & {
  __typename: 'Account';
  /** The API tokens that can be used to authenticate this account when making API calls or using our SDKs. See the "Authentication" section of our API docs for more details on its usage. */
  api_tokens: AccountToApiTokensConnection;
  /** The details of the balance of the nodes owned by this account on the Bitcoin Network. */
  blockchain_balance?: Maybe<BlockchainBalance>;
  /** The channels between the nodes that belong to this account and other nodes. */
  channels: AccountToChannelsConnection;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The total sum of the channel balances (online and offline) on this node. */
  local_balance?: Maybe<CurrencyAmount>;
  /** The name of this account. */
  name?: Maybe<Scalars['String']>;
  /** The nodes that are managed by this account. */
  nodes: AccountToNodesConnection;
  /** The payment requests that have been generated by the nodes of this account. */
  payment_requests: AccountToPaymentRequestsConnection;
  /** The sum of the channel balances that are available to receive on the nodes of this account. */
  remote_balance?: Maybe<CurrencyAmount>;
  /** The transactions that this account is involved. Those can happen on the lightning network (either as a sender, recipient, router) or on the Bitcoin blockchain (as a sender or a recipient). */
  transactions: AccountToTransactionsConnection;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
  /** An integer between 0 and 100 (included) that represents the percentage of uptime for the nodes owned by this account. */
  uptime_percentage?: Maybe<Scalars['Int']>;
  /** The wallets attached to this account. */
  wallets: AccountToWalletsConnection;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountApi_TokensArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountBlockchain_BalanceArgs = {
  bitcoin_networks?: InputMaybe<Array<BitcoinNetwork>>;
  node_ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountChannelsArgs = {
  after_date?: InputMaybe<Scalars['DateTime']>;
  before_date?: InputMaybe<Scalars['DateTime']>;
  bitcoin_network: BitcoinNetwork;
  first?: InputMaybe<Scalars['Int']>;
  lightning_node_id?: InputMaybe<Scalars['ID']>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountConductivityArgs = {
  bitcoin_networks?: InputMaybe<Array<BitcoinNetwork>>;
  node_ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountLocal_BalanceArgs = {
  bitcoin_networks?: InputMaybe<Array<BitcoinNetwork>>;
  node_ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountNodesArgs = {
  bitcoin_networks?: InputMaybe<Array<BitcoinNetwork>>;
  first?: InputMaybe<Scalars['Int']>;
  node_ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountPayment_RequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  after_date?: InputMaybe<Scalars['DateTime']>;
  before_date?: InputMaybe<Scalars['DateTime']>;
  bitcoin_network?: InputMaybe<BitcoinNetwork>;
  first?: InputMaybe<Scalars['Int']>;
  lightning_node_id?: InputMaybe<Scalars['ID']>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountRemote_BalanceArgs = {
  bitcoin_networks?: InputMaybe<Array<BitcoinNetwork>>;
  node_ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountTransactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  after_date?: InputMaybe<Scalars['DateTime']>;
  before_date?: InputMaybe<Scalars['DateTime']>;
  bitcoin_network?: InputMaybe<BitcoinNetwork>;
  exclude_failures?: InputMaybe<TransactionFailures>;
  first?: InputMaybe<Scalars['Int']>;
  lightning_node_id?: InputMaybe<Scalars['ID']>;
  statuses?: InputMaybe<Array<TransactionStatus>>;
  types?: InputMaybe<Array<TransactionType>>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountUptime_PercentageArgs = {
  after_date?: InputMaybe<Scalars['DateTime']>;
  before_date?: InputMaybe<Scalars['DateTime']>;
  bitcoin_networks?: InputMaybe<Array<BitcoinNetwork>>;
  node_ids?: InputMaybe<Array<Scalars['ID']>>;
};


/** This is an object representing the connected Lightspark account. You can retrieve this object to see your account information and objects tied to your account. */
export type AccountWalletsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

export type AccountToApiTokensConnection = {
  __typename: 'AccountToApiTokensConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The API tokens for the current page of this connection. */
  entities: Array<ApiToken>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
};

export type AccountToChannelsConnection = {
  __typename: 'AccountToChannelsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The channels for the current page of this connection. */
  entities: Array<Channel>;
};


export type AccountToChannelsConnectionCountArgs = {
  exclude_failed_closed?: InputMaybe<Scalars['Boolean']>;
};

/** A connection between an account and the nodes it manages. */
export type AccountToNodesConnection = {
  __typename: 'AccountToNodesConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The nodes for the current page of this connection. */
  entities: Array<LightsparkNode>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
};

export type AccountToPaymentRequestsConnection = {
  __typename: 'AccountToPaymentRequestsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count?: Maybe<Scalars['Int']>;
  /** The payment requests for the current page of this connection. */
  entities: Array<PaymentRequest>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
};

export type AccountToTransactionsConnection = {
  __typename: 'AccountToTransactionsConnection';
  /** Average fee earned for the transactions in this connection, with the set of filters and constraints provided. */
  average_fee_earned?: Maybe<CurrencyAmount>;
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The transactions for the current page of this connection. */
  entities: Array<Transaction>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
  /** Profit (or loss) generated by the transactions in this connection, with the set of filters and constraints provided. */
  profit_loss?: Maybe<CurrencyAmount>;
  /** Total amount transacted by the transactions in this connection, with the set of filters and constraints provided. */
  total_amount_transacted?: Maybe<CurrencyAmount>;
};

export type AccountToWalletsConnection = {
  __typename: 'AccountToWalletsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The wallets for the current page of this connection. */
  entities: Array<Wallet>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
};

/** This is an object representing a Lightspark API token, that can be used to authenticate this account when making API calls or using our SDKs. See the “Authentication” section of our API docs for more details on its usage. */
export type ApiToken = Entity & {
  __typename: 'ApiToken';
  /** An opaque identifier that should be used as a client_id (or username) in the HTTP Basic Authentication scheme when issuing requests against the Lightspark API. */
  client_id: Scalars['String'];
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** An arbitrary name chosen by the creator of the token to help identify the token in the list of tokens that have been created for the account. */
  name: Scalars['String'];
  /** A list of permissions granted to the token. */
  permissions: Array<Permission>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This is an object representing the balance associated with your Lightspark account. You can retrieve this object to see your balance, which can be broken down into several different categorizations. */
export type Balances = {
  __typename: 'Balances';
  /**
   * This represents the balance that should be displayed when asked "how much can I send on Lightning right now?".
   *
   * It represents the amount currently available to be sent on the Lightning network. We remove from the balance all the funds that are temporarily locked (e.g. channel reserves).
   */
  available_to_send_balance: CurrencyAmount;
  /**
   * This represents the balance that should be displayed when asked "how much money can I withdraw on the Bitcoin network right now?".
   *
   * It represents the amount currently available to withdraw and is usually equal to the `owned_balance` but it does not include in-flight operations (which would likely succeed and therefore likely make your withdrawal fail).
   */
  available_to_withdraw_balance: CurrencyAmount;
  /**
   * This represents the balance that should be displayed when asked "how much do I own right now?".
   *
   * It represents the amount currently owned, including things that may not be owned soon (e.g. in-flight outgoing payments, in-flight withdrawals, commit fees, etc.). It really is a snapshot of what is officially owned at this instant.
   */
  owned_balance: CurrencyAmount;
};

/** This is an enum identifying a particular Bitcoin Network. */
export enum BitcoinNetwork {
  /** The production version of the Bitcoin Blockchain. */
  Mainnet = 'MAINNET',
  /** A test version of the Bitcoin Blockchain, maintained by Lightspark. */
  Regtest = 'REGTEST',
  /**
   * A test version of the Bitcoin Blockchain, maintained by a centralized organization. Not in use at Lightspark.
   * @deprecated Use REGTEST.
   */
  Signet = 'SIGNET',
  /** A test version of the Bitcoin Blockchain, publicly available. */
  Testnet = 'TESTNET'
}

/** This is an object representing a detailed breakdown of the balance for a Lightspark Node. */
export type BlockchainBalance = {
  __typename: 'BlockchainBalance';
  /** Funds available for creating channels or withdrawing. */
  available_balance?: Maybe<CurrencyAmount>;
  /** The balance of confirmed UTXOs in the wallet. */
  confirmed_balance?: Maybe<CurrencyAmount>;
  /** The balance that's locked by an on-chain transaction. */
  locked_balance?: Maybe<CurrencyAmount>;
  /** Funds required to be held in reserve for channel bumping. */
  required_reserve?: Maybe<CurrencyAmount>;
  /** The total wallet balance, including unconfirmed UTXOs. */
  total_balance?: Maybe<CurrencyAmount>;
  /** The balance of unconfirmed UTXOs in the wallet. */
  unconfirmed_balance?: Maybe<CurrencyAmount>;
};

/** This is an object representing a channel on the Lightning Network. You can retrieve this object to get detailed information on a specific Lightning Network channel. */
export type Channel = Entity & {
  __typename: 'Channel';
  /** The total amount of funds in this channel, including the channel balance on the local node, the channel balance on the remote node and the on-chain fees to close the channel. */
  capacity?: Maybe<CurrencyAmount>;
  /** The amount to be paid in fees for the current set of commitment transactions. */
  commit_fee?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The estimated time to wait for the channel's hash timelock contract to expire when force closing the channel. It is in unit of minutes. */
  estimated_force_closure_wait_minutes?: Maybe<Scalars['Int']>;
  /** The fees charged for routing payments through this channel. */
  fees?: Maybe<ChannelFees>;
  /** The transaction that funded the channel upon channel opening. */
  funding_transaction?: Maybe<ChannelOpeningTransaction>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The channel balance on the local node. */
  local_balance?: Maybe<CurrencyAmount>;
  /** The local Lightspark node of the channel. */
  local_node: LightsparkNode;
  /** The channel balance on the local node that is currently allocated to in-progress payments. */
  local_unsettled_balance?: Maybe<CurrencyAmount>;
  /** The channel balance on the remote node. */
  remote_balance?: Maybe<CurrencyAmount>;
  /** If known, the remote node of the channel. */
  remote_node?: Maybe<Node>;
  /** The channel balance on the remote node that is currently allocated to in-progress payments. */
  remote_unsettled_balance?: Maybe<CurrencyAmount>;
  /** The unique identifier of the channel on Lightning Network, which is the location in the chain that the channel was confirmed. The format is <block-height>:<tx-index>:<tx-output>. */
  short_channel_id?: Maybe<Scalars['String']>;
  /** The current status of this channel. */
  status?: Maybe<ChannelStatus>;
  /** The total balance in this channel, including the channel balance on both local and remote nodes. */
  total_balance?: Maybe<CurrencyAmount>;
  /** A connection to all transactions that have occurred on the channel including outgoing payments, incoming payments, routing transactions and on-chain transactions. */
  transactions: ChannelToTransactionsConnection;
  /** The channel balance that is currently allocated to in-progress payments. */
  unsettled_balance?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
  /** An integer between 0 and 100 (included) that represents the percentage of uptime for this channel. */
  uptime_percentage?: Maybe<Scalars['Int']>;
};


/** This is an object representing a channel on the Lightning Network. You can retrieve this object to get detailed information on a specific Lightning Network channel. */
export type ChannelTransactionsArgs = {
  after_date?: InputMaybe<Scalars['DateTime']>;
  before_date?: InputMaybe<Scalars['DateTime']>;
  types?: InputMaybe<Array<TransactionType>>;
};


/** This is an object representing a channel on the Lightning Network. You can retrieve this object to get detailed information on a specific Lightning Network channel. */
export type ChannelUptime_PercentageArgs = {
  after_date?: InputMaybe<Scalars['DateTime']>;
  before_date?: InputMaybe<Scalars['DateTime']>;
};

/** This is an object representing a transaction which closes a channel on the Lightning Network. This operation allocates balances back to the local and remote nodes. */
export type ChannelClosingTransaction = Entity & OnChainTransaction & Transaction & {
  __typename: 'ChannelClosingTransaction';
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The hash of the block that included this transaction. This will be null for unconfirmed transactions. */
  block_hash?: Maybe<Scalars['String']>;
  /** The height of the block that included this transaction. This will be zero for unconfirmed transactions. */
  block_height: Scalars['Int'];
  /** If known, the channel this transaction is closing. */
  channel?: Maybe<Channel>;
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The Bitcoin blockchain addresses this transaction was sent to. */
  destination_addresses: Array<Scalars['String']>;
  /** The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin blockchain. */
  fees?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The number of blockchain confirmations for this transaction in real time. */
  num_confirmations?: Maybe<Scalars['Int']>;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This represents the fee policies set for a channel on the Lightning Network. */
export type ChannelFees = {
  __typename: 'ChannelFees';
  base_fee?: Maybe<CurrencyAmount>;
  fee_rate_per_mil?: Maybe<Scalars['Int']>;
};

/** This is an object representing a transaction which opens a channel on the Lightning Network. This object occurs only for channels funded by the local Lightspark node. */
export type ChannelOpeningTransaction = Entity & OnChainTransaction & Transaction & {
  __typename: 'ChannelOpeningTransaction';
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The hash of the block that included this transaction. This will be null for unconfirmed transactions. */
  block_hash?: Maybe<Scalars['String']>;
  /** The height of the block that included this transaction. This will be zero for unconfirmed transactions. */
  block_height: Scalars['Int'];
  /** If known, the channel this transaction is opening. */
  channel?: Maybe<Channel>;
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The Bitcoin blockchain addresses this transaction was sent to. */
  destination_addresses: Array<Scalars['String']>;
  /** The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin blockchain. */
  fees?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The number of blockchain confirmations for this transaction in real time. */
  num_confirmations?: Maybe<Scalars['Int']>;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This is an enum representing the status of a channel on the Lightning Network. */
export enum ChannelStatus {
  /** The channel has been closed. Information about the channel is still available for historical purposes but the channel cannot be used anymore. */
  Closed = 'CLOSED',
  /** Something unexpected happened and we cannot determine the status of this channel. Please try again later or contact the support. */
  Error = 'ERROR',
  /** The channel is not available, likely because the peer is not online. */
  Offline = 'OFFLINE',
  /** The channel is online and ready to send and receive funds. */
  Ok = 'OK',
  /** The channel has been created, but the Bitcoin transaction that initiates it still needs to be confirmed on the Bitcoin blockchain. */
  Pending = 'PENDING',
  /** The channel is behaving properly, but its remote balance is much lower than its local balance so it is not balanced properly for receiving funds. */
  UnbalancedForReceive = 'UNBALANCED_FOR_RECEIVE',
  /** The channel is behaving properly, but its remote balance is much higher than its local balance so it is not balanced properly for sending funds out. */
  UnbalancedForSend = 'UNBALANCED_FOR_SEND'
}

export type ChannelToTransactionsConnection = {
  __typename: 'ChannelToTransactionsConnection';
  /** The average fee for the transactions that transited through this channel, according to the filters and constraints of the connection. */
  average_fee?: Maybe<CurrencyAmount>;
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The total amount transacted for the transactions that transited through this channel, according to the filters and constraints of the connection. */
  total_amount_transacted?: Maybe<CurrencyAmount>;
  /** The total amount of fees for the transactions that transited through this channel, according to the filters and constraints of the connection. */
  total_fees?: Maybe<CurrencyAmount>;
};

export type CreateApiTokenInput = {
  /** An arbitrary name that the user can choose to identify the API token in a list. */
  name: Scalars['String'];
  /** List of permissions to grant to the API token */
  permissions: Array<Permission>;
};

export type CreateApiTokenOutput = {
  __typename: 'CreateApiTokenOutput';
  /** The API Token that has been created. */
  api_token: ApiToken;
  /**
   * The secret that should be used to authenticate against our API.
   * This secret is not stored and will never be available again after this. You must keep this secret secure as it grants access to your account.
   */
  client_secret: Scalars['String'];
};

export type CreateInvoiceInput = {
  amount_msats: Scalars['Long'];
  invoice_type?: InputMaybe<InvoiceType>;
  memo?: InputMaybe<Scalars['String']>;
  node_id: Scalars['ID'];
};

export type CreateInvoiceOutput = {
  __typename: 'CreateInvoiceOutput';
  invoice: Invoice;
};

export type CreateLnurlInvoiceInput = {
  /** The amount for which the invoice should be created, in millisatoshis. */
  amount_msats: Scalars['Long'];
  /** The expiry of the invoice in seconds. Default value is 86400 (1 day). */
  expiry_secs?: InputMaybe<Scalars['Int']>;
  /** The SHA256 hash of the LNURL metadata payload. This will be present in the h-tag (SHA256 purpose of payment) of the resulting Bolt 11 invoice. */
  metadata_hash: Scalars['String'];
  /** The node from which to create the invoice. */
  node_id: Scalars['ID'];
};

export type CreateNodeWalletAddressInput = {
  node_id: Scalars['ID'];
};

export type CreateNodeWalletAddressOutput = {
  __typename: 'CreateNodeWalletAddressOutput';
  node: LightsparkNode;
  wallet_address: Scalars['String'];
};

export type CreateTestModeInvoiceInput = {
  amount_msats: Scalars['Long'];
  invoice_type?: InputMaybe<InvoiceType>;
  local_node_id: Scalars['ID'];
  memo?: InputMaybe<Scalars['String']>;
};

export type CreateTestModeInvoiceOutput = {
  __typename: 'CreateTestModeInvoiceOutput';
  encoded_payment_request: Scalars['String'];
};

export type CreateTestModePaymentInput = {
  /** The amount you will be paid for this invoice, expressed in msats. It should ONLY be set when the invoice amount is zero. */
  amount_msats?: InputMaybe<Scalars['Long']>;
  /** The invoice you want to be paid (as defined by the BOLT11 standard). */
  encoded_invoice: Scalars['String'];
  /** The node to where you want to send the payment. */
  local_node_id: Scalars['ID'];
};

/** This is an object identifying the output of a test mode payment. This object can be used to retrieve the associated payment made from a Test Mode Payment call. */
export type CreateTestModePaymentoutput = {
  __typename: 'CreateTestModePaymentoutput';
  /** The payment that has been sent. */
  payment: OutgoingPayment;
};

/** This is an enum identifying a type of crypto sanctions screening provider. */
export enum CryptoSanctionsScreeningProvider {
  Chainalysis = 'CHAINALYSIS'
}

/** This object represents the value and unit for an amount of currency. */
export type CurrencyAmount = {
  __typename: 'CurrencyAmount';
  /** The original unit of currency for this CurrencyAmount. */
  original_unit: CurrencyUnit;
  /** The original numeric value for this CurrencyAmount. */
  original_value: Scalars['Long'];
  /** The unit of user's preferred currency. */
  preferred_currency_unit: CurrencyUnit;
  /** The approximate float value for this CurrencyAmount in the very base level of user's preferred currency. For example, for USD, the value will be in cents. */
  preferred_currency_value_approx: Scalars['Float'];
  /** The rounded numeric value for this CurrencyAmount in the very base level of user's preferred currency. For example, for USD, the value will be in cents. */
  preferred_currency_value_rounded: Scalars['Long'];
};

/** This enum identifies the unit of currency associated with a CurrencyAmount. */
export enum CurrencyUnit {
  /** Bitcoin is the cryptocurrency native to the Bitcoin network. It is used as the native medium for value transfer for the Lightning Network. */
  Bitcoin = 'BITCOIN',
  /**
   * 0.000001 (10e-6) Bitcoin or a millionth of a Bitcoin. We recommend using the Satoshi unit instead when possible.
   * @deprecated Use BITCOIN instead.
   */
  Microbitcoin = 'MICROBITCOIN',
  /**
   * 0.001 (10e-3) Bitcoin or a thousandth of a Bitcoin. We recommend using the Satoshi unit instead when possible.
   * @deprecated Use BITCOIN instead.
   */
  Millibitcoin = 'MILLIBITCOIN',
  /** 0.001 Satoshi, or 10e-11 Bitcoin. We recommend using the Satoshi unit instead when possible. */
  Millisatoshi = 'MILLISATOSHI',
  /**
   * 0.000000001 (10e-9) Bitcoin or a billionth of a Bitcoin. We recommend using the Satoshi unit instead when possible.
   * @deprecated Use BITCOIN instead.
   */
  Nanobitcoin = 'NANOBITCOIN',
  /** 0.00000001 (10e-8) Bitcoin or one hundred millionth of a Bitcoin. This is the unit most commonly used in Lightning transactions. */
  Satoshi = 'SATOSHI',
  /** United States Dollar. */
  Usd = 'USD'
}

export type DeleteApiTokenInput = {
  api_token_id: Scalars['ID'];
};

export type DeleteApiTokenOutput = {
  __typename: 'DeleteApiTokenOutput';
  account: Account;
};

/** This object represents a Deposit made to a Lightspark node wallet. This operation occurs for any L1 funding transaction to the wallet. You can retrieve this object to receive detailed information about the deposit. */
export type Deposit = Entity & OnChainTransaction & Transaction & {
  __typename: 'Deposit';
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The hash of the block that included this transaction. This will be null for unconfirmed transactions. */
  block_hash?: Maybe<Scalars['String']>;
  /** The height of the block that included this transaction. This will be zero for unconfirmed transactions. */
  block_height: Scalars['Int'];
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The recipient Lightspark node this deposit was sent to. */
  destination: LightsparkNode;
  /** The Bitcoin blockchain addresses this transaction was sent to. */
  destination_addresses: Array<Scalars['String']>;
  /** The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin blockchain. */
  fees?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The number of blockchain confirmations for this transaction in real time. */
  num_confirmations?: Maybe<Scalars['Int']>;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This interface is used by all the entities in the Lightspark system. It defines a few core fields that are available everywhere. Any object that implements this interface can be queried using the `entity` query and its ID. */
export type Entity = {
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This object represents the estimated L1 transaction fees for the Bitcoin network. Fee estimates are separated by potential confirmation speeds for settlement. */
export type FeeEstimate = {
  __typename: 'FeeEstimate';
  fee_fast: CurrencyAmount;
  fee_min: CurrencyAmount;
};

export type FundNodeInput = {
  amount_sats?: InputMaybe<Scalars['Long']>;
  node_id: Scalars['ID'];
};

export type FundNodeOutput = {
  __typename: 'FundNodeOutput';
  amount: CurrencyAmount;
};

/** This object represents a node that exists on the Lightning Network, including nodes not managed by Lightspark. You can retrieve this object to get publicly available information about any node on the Lightning Network. */
export type GraphNode = Entity & Node & {
  __typename: 'GraphNode';
  /** The addresses that this node has announced for itself on the Lightning Network. */
  addresses: NodeToAddressesConnection;
  /** A name that identifies the node. It has no importance in terms of operating the node, it is just a way to identify and search for commercial services or popular nodes. This alias can be changed at any time by the node operator. */
  alias?: Maybe<Scalars['String']>;
  /** The Bitcoin Network this node is deployed in. */
  bitcoin_network: BitcoinNetwork;
  /** A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is white. It has no importance in terms of operating the node, it is just a way to visually differentiate nodes. That color can be changed at any time by the node operator. */
  color?: Maybe<Scalars['String']>;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The name of this node in the network. It will be the most human-readable option possible, depending on the data available for this node. */
  display_name: Scalars['String'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The public key of this node. It acts as a unique identifier of this node in the Lightning Network. */
  public_key?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This object represents a node that exists on the Lightning Network, including nodes not managed by Lightspark. You can retrieve this object to get publicly available information about any node on the Lightning Network. */
export type GraphNodeAddressesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<NodeAddressType>>;
};

/** This object represents a specific node that existed on a particular payment route. You can retrieve this object to get information about a node on a particular payment path and all payment-relevant information for that node. */
export type Hop = Entity & {
  __typename: 'Hop';
  /** The amount that is to be forwarded to the destination node. */
  amount_to_forward?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The destination node of the hop. */
  destination?: Maybe<Node>;
  /** The block height at which an unsettled HTLC is considered expired. */
  expiry_block_height?: Maybe<Scalars['Int']>;
  /** The fees to be collected by the source node for forwarding the payment over the hop. */
  fee?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The zero-based index position of this hop in the path */
  index: Scalars['Int'];
  /** The public key of the node to which the hop is bound. */
  public_key?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This is an enum representing a particular reason why an htlc sent over the Lightning Network may have failed. */
export enum HtlcAttemptFailureCode {
  AmountBelowMinimum = 'AMOUNT_BELOW_MINIMUM',
  ChannelDisabled = 'CHANNEL_DISABLED',
  ExpiryTooFar = 'EXPIRY_TOO_FAR',
  ExpiryTooSoon = 'EXPIRY_TOO_SOON',
  FeeInsufficient = 'FEE_INSUFFICIENT',
  FinalExpiryTooSoon = 'FINAL_EXPIRY_TOO_SOON',
  FinalIncorrectCltvExpiry = 'FINAL_INCORRECT_CLTV_EXPIRY',
  FinalIncorrectHtlcAmount = 'FINAL_INCORRECT_HTLC_AMOUNT',
  IncorrectCltvExpiry = 'INCORRECT_CLTV_EXPIRY',
  IncorrectOrUnknownPaymentDetails = 'INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS',
  IncorrectPaymentAmount = 'INCORRECT_PAYMENT_AMOUNT',
  InternalFailure = 'INTERNAL_FAILURE',
  InvalidOnionHmac = 'INVALID_ONION_HMAC',
  InvalidOnionKey = 'INVALID_ONION_KEY',
  InvalidOnionPayload = 'INVALID_ONION_PAYLOAD',
  InvalidOnionVersion = 'INVALID_ONION_VERSION',
  InvalidRealm = 'INVALID_REALM',
  MppTimeout = 'MPP_TIMEOUT',
  PermanentChannelFailure = 'PERMANENT_CHANNEL_FAILURE',
  PermanentNodeFailure = 'PERMANENT_NODE_FAILURE',
  RequiredChannelFeatureMissing = 'REQUIRED_CHANNEL_FEATURE_MISSING',
  RequiredNodeFeatureMissing = 'REQUIRED_NODE_FEATURE_MISSING',
  TemporaryChannelFailure = 'TEMPORARY_CHANNEL_FAILURE',
  TemporaryNodeFailure = 'TEMPORARY_NODE_FAILURE',
  UnknownFailure = 'UNKNOWN_FAILURE',
  UnknownNextPeer = 'UNKNOWN_NEXT_PEER',
  UnreadableFailure = 'UNREADABLE_FAILURE'
}

/** This object represents any payment sent to a Lightspark node on the Lightning Network. You can retrieve this object to receive payment related information about a specific payment received by a Lightspark node. */
export type IncomingPayment = Entity & LightningTransaction & Transaction & {
  __typename: 'IncomingPayment';
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The attempts that have been made for this payment. */
  attempts: IncomingPaymentToAttemptsConnection;
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The recipient Lightspark node this payment was sent to. */
  destination: LightsparkNode;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The optional payment request for this incoming payment, which will be null if the payment is sent through keysend. */
  payment_request?: Maybe<PaymentRequest>;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This object represents any payment sent to a Lightspark node on the Lightning Network. You can retrieve this object to receive payment related information about a specific payment received by a Lightspark node. */
export type IncomingPaymentAttemptsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<IncomingPaymentAttemptStatus>>;
};

/** This object represents any attempted payment sent to a Lightspark node on the Lightning Network. You can retrieve this object to receive payment related information about a specific incoming payment attempt. */
export type IncomingPaymentAttempt = Entity & {
  __typename: 'IncomingPaymentAttempt';
  /** The total amount of that was attempted to send. */
  amount: CurrencyAmount;
  /** The channel this attempt was made on. */
  channel: Channel;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The time the incoming payment attempt failed or succeeded. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The status of the incoming payment attempt. */
  status: IncomingPaymentAttemptStatus;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This is an enum that enumerates all potential statuses for an incoming payment attempt. */
export enum IncomingPaymentAttemptStatus {
  Accepted = 'ACCEPTED',
  Canceled = 'CANCELED',
  Settled = 'SETTLED',
  Unknown = 'UNKNOWN'
}

/** The connection from incoming payment to all attempts. */
export type IncomingPaymentToAttemptsConnection = {
  __typename: 'IncomingPaymentToAttemptsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The incoming payment attempts for the current page of this connection. */
  entities: Array<IncomingPaymentAttempt>;
};

/** This object represents a BOLT #11 invoice (https://github.com/lightning/bolts/blob/master/11-payment-encoding.md) created by a Lightspark Node. You can retrieve this object to receive relevant payment information for a specific invoice generated by a Lightspark node. */
export type Invoice = Entity & PaymentRequest & {
  __typename: 'Invoice';
  /** The total amount that has been paid to this invoice. */
  amount_paid?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The details of the invoice. */
  data: InvoiceData;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The status of the payment request. */
  status: PaymentRequestStatus;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This object represents the data associated with a BOLT #11 invoice. You can retrieve this object to receive the relevant data associated with a specific invoice. */
export type InvoiceData = PaymentRequestData & {
  __typename: 'InvoiceData';
  /** The requested amount in this invoice. If it is equal to 0, the sender should choose the amount to send. */
  amount: CurrencyAmount;
  bitcoin_network: BitcoinNetwork;
  /** The date and time when this invoice was created. */
  created_at: Scalars['DateTime'];
  /** The lightning node that will be paid when fulfilling this invoice. */
  destination: Node;
  encoded_payment_request: Scalars['String'];
  /** The date and time when this invoice will expire. */
  expires_at: Scalars['DateTime'];
  /** A short, UTF-8 encoded, description of the purpose of this invoice. */
  memo?: Maybe<Scalars['String']>;
  /** The payment hash of this invoice. */
  payment_hash: Scalars['String'];
};

/** This is an enum for potential invoice types. */
export enum InvoiceType {
  /** An AMP (Atomic Multi-path Payment) invoice. */
  Amp = 'AMP',
  /** A standard Bolt 11 invoice. */
  Standard = 'STANDARD'
}

export type LightningFeeEstimateForInvoiceInput = {
  /** If the invoice does not specify a payment amount, then the amount that you wish to pay, expressed in msats. */
  amount_msats?: InputMaybe<Scalars['Long']>;
  /** The invoice you want to pay (as defined by the BOLT11 standard). */
  encoded_payment_request: Scalars['String'];
  /** The node from where you want to send the payment. */
  node_id: Scalars['ID'];
};

export type LightningFeeEstimateForNodeInput = {
  /** The payment amount expressed in msats. */
  amount_msats: Scalars['Long'];
  /** The public key of the node that you want to pay. */
  destination_node_public_key: Scalars['String'];
  /** The node from where you want to send the payment. */
  node_id: Scalars['ID'];
};

export type LightningFeeEstimateOutput = {
  __typename: 'LightningFeeEstimateOutput';
  /** The estimated fees for the payment. */
  fee_estimate: CurrencyAmount;
};

/** This is an object representing a transaction made over the Lightning Network. You can retrieve this object to receive information about a specific transaction made over Lightning for a Lightspark node. */
export type LightningTransaction = {
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This is an object representing a node managed by Lightspark and owned by the current connected account. This object contains information about the node’s configuration, state, and metadata. */
export type LightsparkNode = {
  /** The addresses that this node has announced for itself on the Lightning Network. */
  addresses: NodeToAddressesConnection;
  /** A name that identifies the node. It has no importance in terms of operating the node, it is just a way to identify and search for commercial services or popular nodes. This alias can be changed at any time by the node operator. */
  alias?: Maybe<Scalars['String']>;
  /** The Bitcoin Network this node is deployed in. */
  bitcoin_network: BitcoinNetwork;
  /** The details of the balance of this node on the Bitcoin Network. */
  blockchain_balance?: Maybe<BlockchainBalance>;
  /** The channels that are connected to this node. */
  channels: LightsparkNodeToChannelsConnection;
  /** A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is white. It has no importance in terms of operating the node, it is just a way to visually differentiate nodes. That color can be changed at any time by the node operator. */
  color?: Maybe<Scalars['String']>;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The name of this node in the network. It will be the most human-readable option possible, depending on the data available for this node. */
  display_name: Scalars['String'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The sum of the channel balances (online only) that are available to send on this node. */
  local_balance?: Maybe<CurrencyAmount>;
  /** The owner of this LightsparkNode. */
  owner: LightsparkNodeOwner;
  /** The public key of this node. It acts as a unique identifier of this node in the Lightning Network. */
  public_key?: Maybe<Scalars['String']>;
  /** The sum of the channel balances that are available to receive on this node. */
  remote_balance?: Maybe<CurrencyAmount>;
  /** The current status of this node. */
  status?: Maybe<LightsparkNodeStatus>;
  /** The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this node. */
  total_balance?: Maybe<CurrencyAmount>;
  /** The total sum of the channel balances (online and offline) on this node. */
  total_local_balance?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This is an object representing a node managed by Lightspark and owned by the current connected account. This object contains information about the node’s configuration, state, and metadata. */
export type LightsparkNodeAddressesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<NodeAddressType>>;
};


/** This is an object representing a node managed by Lightspark and owned by the current connected account. This object contains information about the node’s configuration, state, and metadata. */
export type LightsparkNodeChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<ChannelStatus>>;
};

/** This is an object representing the owner of a LightsparkNode. */
export type LightsparkNodeOwner = {
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

export enum LightsparkNodeStatus {
  Created = 'CREATED',
  Deployed = 'DEPLOYED',
  FailedToDeploy = 'FAILED_TO_DEPLOY',
  Ready = 'READY',
  Started = 'STARTED',
  Stopped = 'STOPPED',
  Syncing = 'SYNCING',
  Terminated = 'TERMINATED',
  Terminating = 'TERMINATING',
  WalletLocked = 'WALLET_LOCKED'
}

export type LightsparkNodeToChannelsConnection = {
  __typename: 'LightsparkNodeToChannelsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The channels for the current page of this connection. */
  entities: Array<Channel>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
};

/** This is a Lightspark node with OSK on LND. */
export type LightsparkNodeWithOsklnd = Entity & LightsparkNode & Node & {
  __typename: 'LightsparkNodeWithOSKLND';
  /** The addresses that this node has announced for itself on the Lightning Network. */
  addresses: NodeToAddressesConnection;
  /** A name that identifies the node. It has no importance in terms of operating the node, it is just a way to identify and search for commercial services or popular nodes. This alias can be changed at any time by the node operator. */
  alias?: Maybe<Scalars['String']>;
  /** The Bitcoin Network this node is deployed in. */
  bitcoin_network: BitcoinNetwork;
  /** The details of the balance of this node on the Bitcoin Network. */
  blockchain_balance?: Maybe<BlockchainBalance>;
  /** The channels that are connected to this node. */
  channels: LightsparkNodeToChannelsConnection;
  /** A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is white. It has no importance in terms of operating the node, it is just a way to visually differentiate nodes. That color can be changed at any time by the node operator. */
  color?: Maybe<Scalars['String']>;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The name of this node in the network. It will be the most human-readable option possible, depending on the data available for this node. */
  display_name: Scalars['String'];
  /** The private key client is using to sign a GraphQL request which will be verified at LND. */
  encrypted_signing_private_key?: Maybe<Secret>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The sum of the channel balances (online only) that are available to send on this node. */
  local_balance?: Maybe<CurrencyAmount>;
  /** The owner of this LightsparkNode. */
  owner: LightsparkNodeOwner;
  /** The public key of this node. It acts as a unique identifier of this node in the Lightning Network. */
  public_key?: Maybe<Scalars['String']>;
  /** The sum of the channel balances that are available to receive on this node. */
  remote_balance?: Maybe<CurrencyAmount>;
  /** The current status of this node. */
  status?: Maybe<LightsparkNodeStatus>;
  /** The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this node. */
  total_balance?: Maybe<CurrencyAmount>;
  /** The total sum of the channel balances (online and offline) on this node. */
  total_local_balance?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This is a Lightspark node with OSK on LND. */
export type LightsparkNodeWithOsklndAddressesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<NodeAddressType>>;
};


/** This is a Lightspark node with OSK on LND. */
export type LightsparkNodeWithOsklndChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<ChannelStatus>>;
};

/** This is a Sparknode with OSK. */
export type LightsparkNodeWithOskSparknode = Entity & LightsparkNode & Node & Sparknode & {
  __typename: 'LightsparkNodeWithOSKSparknode';
  /** The addresses that this node has announced for itself on the Lightning Network. */
  addresses: NodeToAddressesConnection;
  /** A name that identifies the node. It has no importance in terms of operating the node, it is just a way to identify and search for commercial services or popular nodes. This alias can be changed at any time by the node operator. */
  alias?: Maybe<Scalars['String']>;
  /** The Bitcoin Network this node is deployed in. */
  bitcoin_network: BitcoinNetwork;
  /** The details of the balance of this node on the Bitcoin Network. */
  blockchain_balance?: Maybe<BlockchainBalance>;
  /** The channels that are connected to this node. */
  channels: LightsparkNodeToChannelsConnection;
  /** A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is white. It has no importance in terms of operating the node, it is just a way to visually differentiate nodes. That color can be changed at any time by the node operator. */
  color?: Maybe<Scalars['String']>;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The name of this node in the network. It will be the most human-readable option possible, depending on the data available for this node. */
  display_name: Scalars['String'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The sum of the channel balances (online only) that are available to send on this node. */
  local_balance?: Maybe<CurrencyAmount>;
  /** The owner of this LightsparkNode. */
  owner: LightsparkNodeOwner;
  /** The public key of this node. It acts as a unique identifier of this node in the Lightning Network. */
  public_key?: Maybe<Scalars['String']>;
  /** The sum of the channel balances that are available to receive on this node. */
  remote_balance?: Maybe<CurrencyAmount>;
  /** The current status of this node. */
  status?: Maybe<LightsparkNodeStatus>;
  /** The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this node. */
  total_balance?: Maybe<CurrencyAmount>;
  /** The total sum of the channel balances (online and offline) on this node. */
  total_local_balance?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This is a Sparknode with OSK. */
export type LightsparkNodeWithOskSparknodeAddressesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<NodeAddressType>>;
};


/** This is a Sparknode with OSK. */
export type LightsparkNodeWithOskSparknodeChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<ChannelStatus>>;
};

/** This is a Sparknode with server remote signing. */
export type LightsparkNodeWithServerSigning = Entity & LightsparkNode & Node & Sparknode & {
  __typename: 'LightsparkNodeWithServerSigning';
  /** The addresses that this node has announced for itself on the Lightning Network. */
  addresses: NodeToAddressesConnection;
  /** A name that identifies the node. It has no importance in terms of operating the node, it is just a way to identify and search for commercial services or popular nodes. This alias can be changed at any time by the node operator. */
  alias?: Maybe<Scalars['String']>;
  /** The Bitcoin Network this node is deployed in. */
  bitcoin_network: BitcoinNetwork;
  /** The details of the balance of this node on the Bitcoin Network. */
  blockchain_balance?: Maybe<BlockchainBalance>;
  /** The channels that are connected to this node. */
  channels: LightsparkNodeToChannelsConnection;
  /** A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is white. It has no importance in terms of operating the node, it is just a way to visually differentiate nodes. That color can be changed at any time by the node operator. */
  color?: Maybe<Scalars['String']>;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The name of this node in the network. It will be the most human-readable option possible, depending on the data available for this node. */
  display_name: Scalars['String'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The sum of the channel balances (online only) that are available to send on this node. */
  local_balance?: Maybe<CurrencyAmount>;
  /** The owner of this LightsparkNode. */
  owner: LightsparkNodeOwner;
  /** The public key of this node. It acts as a unique identifier of this node in the Lightning Network. */
  public_key?: Maybe<Scalars['String']>;
  /** The sum of the channel balances that are available to receive on this node. */
  remote_balance?: Maybe<CurrencyAmount>;
  /** The current status of this node. */
  status?: Maybe<LightsparkNodeStatus>;
  /** The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this node. */
  total_balance?: Maybe<CurrencyAmount>;
  /** The total sum of the channel balances (online and offline) on this node. */
  total_local_balance?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This is a Sparknode with server remote signing. */
export type LightsparkNodeWithServerSigningAddressesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<NodeAddressType>>;
};


/** This is a Sparknode with server remote signing. */
export type LightsparkNodeWithServerSigningChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<ChannelStatus>>;
};

export type Mutation = {
  __typename: 'Mutation';
  /** This function creates a new API token that can be used to authenticate requests for this account when using the Lightspark APIs and SDKs. */
  create_api_token: CreateApiTokenOutput;
  /** This function generates a Lightning Invoice (following the Bolt 11 specification). This invoice can be used to request a payment from any other Lightning Node. If you are in test mode, the generated invoice can only be paid by the create_test_mode_payment mutation. */
  create_invoice: CreateInvoiceOutput;
  /** This function generates a Lightning Invoice (following the Bolt 11 specification). This invoice can be used to request a payment from any other Lightning Node. This function should only be used for generating invoices for LNURLs, with `create_invoice` preferred in the general case. */
  create_lnurl_invoice: CreateInvoiceOutput;
  /** This function creates a Bitcoin address for the wallet associated with your Lightning Node. You can use this address to send funds to your node. It is a best practice to generate a new wallet address every time you need to send money. You can generate as many wallet addresses as you want. */
  create_node_wallet_address: CreateNodeWalletAddressOutput;
  /** In test mode, this function generates a Lightning Invoice which can be paid by a local node in the test mode environment. */
  create_test_mode_invoice: CreateTestModeInvoiceOutput;
  /** In test mode, this function simulates sending a payment from your Lightspark node given a test mode invoice. */
  create_test_mode_payment: CreateTestModePaymentoutput;
  /** Deletes an existing API token from your Lightspark account. */
  delete_api_token: DeleteApiTokenOutput;
  /**
   * Adds funds to a Lightspark node in test mode, on the REGTEST network. If the amount is not specified, 10,000,000 SATOSHI will be added.
   * This API only functions for nodes created on the REGTEST network and will return an error when called for any non-REGTEST node.
   */
  fund_node: FundNodeOutput;
  /** Sends a payment to a node on the Lightning Network, based on the invoice (as defined by the BOLT11 specification) that you provide. If you are in test mode, the invoice has to be generated by the create_test_mode_invoice mutation. */
  pay_invoice: PayInvoiceOutput;
  /** Release per commitment secret of a channel connecting to a local remote signing node. */
  release_channel_per_commitment_secret: ReleaseChannelPerCommitmentSecretOutput;
  /** Release the payment preimage for an invoice. */
  release_payment_preimage: ReleasePaymentPreimageOutput;
  /**
   * Withdraws funds from the account and sends it to the requested bitcoin address.
   *
   * Depending on the chosen mode, it will first take the funds from the wallet, and if applicable, close channels appropriately to recover enough funds and reopen channels with the remaining funds.
   * The process is asynchronous and may take up to a few minutes. You can check the progress by polling the `WithdrawalRequest` that is created, or by subscribing to a webhook.
   */
  request_withdrawal: RequestWithdrawalOutput;
  /** This function screens a Bitcoin address against a CryptoSanctionsScreeningProvider and returns a risk rating for the associated Bitcoin address. You can call this mutation when performing risk or compliance assessments. */
  screen_bitcoin_addresses: ScreenBitcoinAddressesOutput;
  /** Sends a payment directly to a node on the Lightning Network through the public key of the node without an invoice. */
  send_payment: SendPaymentOutput;
  /** Sign an invoice generated from a remote signing node. */
  sign_invoice: SignInvoiceOutput;
  /** Upload the signatures of a list of messages that need to be signed. */
  sign_messages: SignMessagesOutput;
  /** Updates per commitment point of a channel connecting to a local remote signing node. */
  update_channel_per_commitment_point: UpdateChannelPerCommitmentPointOutput;
  /** Updates shared scret of a remote signing node. */
  update_node_shared_secret: UpdateNodeSharedSecretOutput;
};


export type MutationCreate_Api_TokenArgs = {
  input: CreateApiTokenInput;
};


export type MutationCreate_InvoiceArgs = {
  input: CreateInvoiceInput;
};


export type MutationCreate_Lnurl_InvoiceArgs = {
  input: CreateLnurlInvoiceInput;
};


export type MutationCreate_Node_Wallet_AddressArgs = {
  input: CreateNodeWalletAddressInput;
};


export type MutationCreate_Test_Mode_InvoiceArgs = {
  input: CreateTestModeInvoiceInput;
};


export type MutationCreate_Test_Mode_PaymentArgs = {
  input: CreateTestModePaymentInput;
};


export type MutationDelete_Api_TokenArgs = {
  input: DeleteApiTokenInput;
};


export type MutationFund_NodeArgs = {
  input: FundNodeInput;
};


export type MutationPay_InvoiceArgs = {
  input: PayInvoiceInput;
};


export type MutationRelease_Channel_Per_Commitment_SecretArgs = {
  input: ReleaseChannelPerCommitmentSecretInput;
};


export type MutationRelease_Payment_PreimageArgs = {
  input: ReleasePaymentPreimageInput;
};


export type MutationRequest_WithdrawalArgs = {
  input: RequestWithdrawalInput;
};


export type MutationScreen_Bitcoin_AddressesArgs = {
  input: ScreenBitcoinAddressesInput;
};


export type MutationSend_PaymentArgs = {
  input: SendPaymentInput;
};


export type MutationSign_InvoiceArgs = {
  input: SignInvoiceInput;
};


export type MutationSign_MessagesArgs = {
  input: SignMessagesInput;
};


export type MutationUpdate_Channel_Per_Commitment_PointArgs = {
  input: UpdateChannelPerCommitmentPointInput;
};


export type MutationUpdate_Node_Shared_SecretArgs = {
  input: UpdateNodeSharedSecretInput;
};

/** This object is an interface representing a Lightning Node on the Lightning Network, and could either be a Lightspark node or a node managed by a third party. */
export type Node = {
  /** The addresses that this node has announced for itself on the Lightning Network. */
  addresses: NodeToAddressesConnection;
  /** A name that identifies the node. It has no importance in terms of operating the node, it is just a way to identify and search for commercial services or popular nodes. This alias can be changed at any time by the node operator. */
  alias?: Maybe<Scalars['String']>;
  /** The Bitcoin Network this node is deployed in. */
  bitcoin_network: BitcoinNetwork;
  /** A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is white. It has no importance in terms of operating the node, it is just a way to visually differentiate nodes. That color can be changed at any time by the node operator. */
  color?: Maybe<Scalars['String']>;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The name of this node in the network. It will be the most human-readable option possible, depending on the data available for this node. */
  display_name: Scalars['String'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The public key of this node. It acts as a unique identifier of this node in the Lightning Network. */
  public_key?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This object is an interface representing a Lightning Node on the Lightning Network, and could either be a Lightspark node or a node managed by a third party. */
export type NodeAddressesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<NodeAddressType>>;
};

/** This object represents the address of a node on the Lightning Network. */
export type NodeAddress = {
  __typename: 'NodeAddress';
  /** The string representation of the address. */
  address: Scalars['String'];
  /** The type, or protocol, of this address. */
  type: NodeAddressType;
};

/** This is an enum of the potential types of addresses that a node on the Lightning Network can have. */
export enum NodeAddressType {
  Ipv4 = 'IPV4',
  Ipv6 = 'IPV6',
  Tor = 'TOR'
}

/** A connection between a node and the addresses it has announced for itself on Lightning Network. */
export type NodeToAddressesConnection = {
  __typename: 'NodeToAddressesConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The addresses for the current page of this connection. */
  entities: Array<NodeAddress>;
};

/** This object represents an L1 transaction that occurred on the Bitcoin Network. You can retrieve this object to receive information about a specific on-chain transaction made on the Lightning Network associated with your Lightspark Node. */
export type OnChainTransaction = {
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The hash of the block that included this transaction. This will be null for unconfirmed transactions. */
  block_hash?: Maybe<Scalars['String']>;
  /** The height of the block that included this transaction. This will be zero for unconfirmed transactions. */
  block_height: Scalars['Int'];
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The Bitcoin blockchain addresses this transaction was sent to. */
  destination_addresses: Array<Scalars['String']>;
  /** The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin blockchain. */
  fees?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The number of blockchain confirmations for this transaction in real time. */
  num_confirmations?: Maybe<Scalars['Int']>;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This object represents a Lightning Network payment sent from a Lightspark Node. You can retrieve this object to receive payment related information about any payment sent from your Lightspark Node on the Lightning Network. */
export type OutgoingPayment = Entity & LightningTransaction & Transaction & {
  __typename: 'OutgoingPayment';
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The attempts that have been made for this payment for possible routes. */
  attempts: OutgoingPaymentToAttemptsConnection;
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** If known, the final recipient node this payment was sent to. */
  destination?: Maybe<Node>;
  /** If applicable, user-facing error message describing why the payment failed. */
  failure_message?: Maybe<RichText>;
  /** If applicable, the reason why the payment failed. */
  failure_reason?: Maybe<PaymentFailureReason>;
  /** The fees paid by the sender node to send the payment. */
  fees?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The Lightspark node this payment originated from. */
  origin: LightsparkNode;
  /** The data of the payment request that was paid by this transaction, if known. */
  payment_request_data?: Maybe<PaymentRequestData>;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This object represents a Lightning Network payment sent from a Lightspark Node. You can retrieve this object to receive payment related information about any payment sent from your Lightspark Node on the Lightning Network. */
export type OutgoingPaymentAttemptsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

/** This object represents an attempted Lightning Network payment sent from a Lightspark Node. You can retrieve this object to receive payment related information about any payment attempt sent from your Lightspark Node on the Lightning Network, including any potential reasons the payment may have failed. */
export type OutgoingPaymentAttempt = Entity & {
  __typename: 'OutgoingPaymentAttempt';
  /** The total amount of funds required to complete a payment over this route. This value includes the cumulative fees for each hop. As a result, the attempt extended to the first-hop in the route will need to have at least this much value, otherwise the route will fail at an intermediate node due to an insufficient amount. */
  amount?: Maybe<CurrencyAmount>;
  /** The date and time when the attempt was initiated. */
  created_at: Scalars['DateTime'];
  /** If the payment attempt failed, then this contains the Bolt #4 failure code. */
  failure_code?: Maybe<HtlcAttemptFailureCode>;
  /** If the payment attempt failed, then this contains the index of the hop at which the problem occurred. */
  failure_source_index?: Maybe<Scalars['Int']>;
  /** The sum of the fees paid at each hop within the route of this attempt. In the case of a one-hop payment, this value will be zero as we don't need to pay a fee to ourselves. */
  fees?: Maybe<CurrencyAmount>;
  /** A list of hops that represent the route from the sender node to the recipient node. */
  hops: OutgoingPaymentAttemptToHopsConnection;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The outgoing payment for this attempt. */
  outgoing_payment: OutgoingPayment;
  /** The time the outgoing payment attempt failed or succeeded. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The status of an outgoing payment attempt. */
  status: OutgoingPaymentAttemptStatus;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This object represents an attempted Lightning Network payment sent from a Lightspark Node. You can retrieve this object to receive payment related information about any payment attempt sent from your Lightspark Node on the Lightning Network, including any potential reasons the payment may have failed. */
export type OutgoingPaymentAttemptHopsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

/** This is an enum of all potential statuses of a payment attempt made from a Lightspark Node. */
export enum OutgoingPaymentAttemptStatus {
  Failed = 'FAILED',
  InFlight = 'IN_FLIGHT',
  Succeeded = 'SUCCEEDED'
}

/** The connection from an outgoing payment attempt to the list of sequential hops that define the path from sender node to recipient node. */
export type OutgoingPaymentAttemptToHopsConnection = {
  __typename: 'OutgoingPaymentAttemptToHopsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The hops for the current page of this connection. */
  entities: Array<Hop>;
};

/** The connection from outgoing payment to all attempts. */
export type OutgoingPaymentToAttemptsConnection = {
  __typename: 'OutgoingPaymentToAttemptsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The attempts for the current page of this connection. */
  entities: Array<OutgoingPaymentAttempt>;
};

/** This is an object representing information about a page returned by the Lightspark API. For more information, please see the “Pagination” section of our API docs for more information about its usage. */
export type PageInfo = {
  __typename: 'PageInfo';
  end_cursor?: Maybe<Scalars['String']>;
  has_next_page?: Maybe<Scalars['Boolean']>;
  has_previous_page?: Maybe<Scalars['Boolean']>;
  start_cursor?: Maybe<Scalars['String']>;
};

export type PayInvoiceInput = {
  /** The amount you will pay for this invoice, expressed in msats. It should ONLY be set when the invoice amount is zero. */
  amount_msats?: InputMaybe<Scalars['Long']>;
  /** The invoice you want to pay (as defined by the BOLT11 standard). */
  encoded_invoice: Scalars['String'];
  /** The maximum amount of fees that you want to pay for this payment to be sent, expressed in msats. */
  maximum_fees_msats: Scalars['Long'];
  /** The node from where you want to send the payment. */
  node_id: Scalars['ID'];
  /** The timeout in seconds that we will try to make the payment. */
  timeout_secs: Scalars['Int'];
};

export type PayInvoiceOutput = {
  __typename: 'PayInvoiceOutput';
  /** The payment that has been sent. */
  payment: OutgoingPayment;
};

/** This is an enum of the potential reasons why an OutgoingPayment sent from a Lightspark Node may have failed. */
export enum PaymentFailureReason {
  Error = 'ERROR',
  IncorrectPaymentDetails = 'INCORRECT_PAYMENT_DETAILS',
  InsufficientBalance = 'INSUFFICIENT_BALANCE',
  InvoiceAlreadyPaid = 'INVOICE_ALREADY_PAID',
  InvoiceExpired = 'INVOICE_EXPIRED',
  None = 'NONE',
  NoRoute = 'NO_ROUTE',
  RiskScreeningFailed = 'RISK_SCREENING_FAILED',
  SelfPayment = 'SELF_PAYMENT',
  Timeout = 'TIMEOUT'
}

/** This object contains information related to a payment request generated or received by a LightsparkNode. You can retrieve this object to receive payment information about a specific invoice. */
export type PaymentRequest = {
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The details of the payment request. */
  data: PaymentRequestData;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The status of the payment request. */
  status: PaymentRequestStatus;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This object is an interface of a payment request on the Lightning Network (i.e., a Lightning Invoice). It contains data related to parsing the payment details of a Lightning Invoice. */
export type PaymentRequestData = {
  bitcoin_network: BitcoinNetwork;
  encoded_payment_request: Scalars['String'];
};

/** This is an enum of the potential states that a payment request on the Lightning Network can take. */
export enum PaymentRequestStatus {
  Closed = 'CLOSED',
  Open = 'OPEN'
}

/** This is an enum of the potential permissions that a Lightspark user can have in regards to account management. */
export enum Permission {
  AccountManage = 'ACCOUNT_MANAGE',
  AccountView = 'ACCOUNT_VIEW',
  All = 'ALL',
  MainnetManage = 'MAINNET_MANAGE',
  MainnetTransact = 'MAINNET_TRANSACT',
  MainnetView = 'MAINNET_VIEW',
  RegtestManage = 'REGTEST_MANAGE',
  RegtestTransact = 'REGTEST_TRANSACT',
  RegtestView = 'REGTEST_VIEW',
  TestnetManage = 'TESTNET_MANAGE',
  TestnetTransact = 'TESTNET_TRANSACT',
  TestnetView = 'TESTNET_VIEW',
  UserManage = 'USER_MANAGE',
  UserView = 'USER_VIEW'
}

export type Query = {
  __typename: 'Query';
  /** This is a query that retrieves the current fee estimates for an L1 transaction. You can call this query to get estimates for different confirmation speeds of an L1 transaction on a specific Bitcoin Network. */
  bitcoin_fee_estimate: FeeEstimate;
  /** This is a query that retrieves the currently connected Lightspark account. You can call this query to get an object with detailed information about your connected Lightspark account. */
  current_account?: Maybe<Account>;
  /** This is a query that decodes a Lightning payment request into structured data that can be used by the client. */
  decoded_payment_request: PaymentRequestData;
  /** This is a query that returns any Entity object from the Lightspark API. You can call this query when you want to receive detailed information about any particular Entity. */
  entity?: Maybe<Entity>;
  /** This is a query for estimating what the Lightning Network fees for paying a specific Lightning Invoice. */
  lightning_fee_estimate_for_invoice: LightningFeeEstimateOutput;
  /** This is a query for estimating what the Lightning Network fees will be for sending a payment to a specific Lightning Node. */
  lightning_fee_estimate_for_node: LightningFeeEstimateOutput;
};


export type QueryBitcoin_Fee_EstimateArgs = {
  network: BitcoinNetwork;
};


export type QueryDecoded_Payment_RequestArgs = {
  encoded_payment_request: Scalars['String'];
};


export type QueryEntityArgs = {
  id: Scalars['ID'];
};


export type QueryLightning_Fee_Estimate_For_InvoiceArgs = {
  input: LightningFeeEstimateForInvoiceInput;
};


export type QueryLightning_Fee_Estimate_For_NodeArgs = {
  input: LightningFeeEstimateForNodeInput;
};

export type ReleaseChannelPerCommitmentSecretInput = {
  channel_id: Scalars['ID'];
  per_commitment_secret: Scalars['Hash32'];
};

export type ReleaseChannelPerCommitmentSecretOutput = {
  __typename: 'ReleaseChannelPerCommitmentSecretOutput';
  channel: Channel;
};

export type ReleasePaymentPreimageInput = {
  /** The invoice the preimage belongs to. */
  invoice_id: Scalars['ID'];
  /** The preimage to release. */
  payment_preimage: Scalars['Hash32'];
};

export type ReleasePaymentPreimageOutput = {
  __typename: 'ReleasePaymentPreimageOutput';
  invoice: Invoice;
};

/** This is an enum of the potential sub-event types for Remote Signing webook events. */
export enum RemoteSigningSubEventType {
  DeriveKeyAndSign = 'DERIVE_KEY_AND_SIGN',
  Ecdh = 'ECDH',
  GetPerCommitmentPoint = 'GET_PER_COMMITMENT_POINT',
  ReleasePaymentPreimage = 'RELEASE_PAYMENT_PREIMAGE',
  ReleasePerCommitmentSecret = 'RELEASE_PER_COMMITMENT_SECRET',
  SignInvoice = 'SIGN_INVOICE'
}

export type RequestWithdrawalInput = {
  /** The amount you want to withdraw from this node in Satoshis. Use the special value -1 to withdrawal all funds from this node. */
  amount_sats: Scalars['Long'];
  /** The bitcoin address where the withdrawal should be sent. */
  bitcoin_address: Scalars['String'];
  /** The node from which you'd like to make the withdrawal. */
  node_id: Scalars['ID'];
  /** The strategy that should be used to withdraw the funds from this node. */
  withdrawal_mode: WithdrawalMode;
};

export type RequestWithdrawalOutput = {
  __typename: 'RequestWithdrawalOutput';
  /** The request that is created for this withdrawal. */
  request: WithdrawalRequest;
};

export type RichText = {
  __typename: 'RichText';
  text: Scalars['String'];
};

/** This is an enum of the potential risk ratings related to a transaction made over the Lightning Network. These risk ratings are returned from the CryptoSanctionScreeningProvider. */
export enum RiskRating {
  HighRisk = 'HIGH_RISK',
  LowRisk = 'LOW_RISK',
  Unknown = 'UNKNOWN'
}

/** This object represents a transaction that was forwarded through a Lightspark node on the Lightning Network, i.e., a routed transaction. You can retrieve this object to receive information about any transaction routed through your Lightspark Node. */
export type RoutingTransaction = Entity & LightningTransaction & Transaction & {
  __typename: 'RoutingTransaction';
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** If applicable, user-facing error message describing why the routing failed. */
  failure_message?: Maybe<RichText>;
  /** If applicable, the reason why the routing failed. */
  failure_reason?: Maybe<RoutingTransactionFailureReason>;
  /** The fees collected by the node when routing this transaction. We subtract the outgoing amount to the incoming amount to determine how much fees were collected. */
  fees?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** If known, the channel this transaction was received from. */
  incoming_channel?: Maybe<Channel>;
  /** If known, the channel this transaction was forwarded to. */
  outgoing_channel?: Maybe<Channel>;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This is an enum of the potential reasons that an attempted routed transaction through a Lightspark node may have failed. */
export enum RoutingTransactionFailureReason {
  ForwardingFailure = 'FORWARDING_FAILURE',
  IncomingLinkFailure = 'INCOMING_LINK_FAILURE',
  OutgoingLinkFailure = 'OUTGOING_LINK_FAILURE'
}

export type ScreenBitcoinAddressesInput = {
  addresses: Array<Scalars['String']>;
  provider: CryptoSanctionsScreeningProvider;
};

export type ScreenBitcoinAddressesOutput = {
  __typename: 'ScreenBitcoinAddressesOutput';
  ratings: Array<RiskRating>;
};

export type Secret = {
  __typename: 'Secret';
  cipher: Scalars['String'];
  encrypted_value: Scalars['String'];
};

export type SendPaymentInput = {
  /** The amount you will send to the destination node, expressed in msats. */
  amount_msats: Scalars['Long'];
  /** The public key of the destination node. */
  destination_public_key: Scalars['String'];
  /** The maximum amount of fees that you want to pay for this payment to be sent, expressed in msats. */
  maximum_fees_msats: Scalars['Long'];
  /** The node from where you want to send the payment. */
  node_id: Scalars['ID'];
  /** The timeout in seconds that we will try to make the payment. */
  timeout_secs: Scalars['Int'];
};

export type SendPaymentOutput = {
  __typename: 'SendPaymentOutput';
  /** The payment that has been sent. */
  payment: OutgoingPayment;
};

export type SignInvoiceInput = {
  invoice_id: Scalars['ID'];
  recovery_id: Scalars['Int'];
  signature: Scalars['String'];
};

export type SignInvoiceOutput = {
  __typename: 'SignInvoiceOutput';
  invoice: Invoice;
};

export type SignMessagesInput = {
  signatures: Array<Signature>;
};

export type SignMessagesOutput = {
  __typename: 'SignMessagesOutput';
  signed_payloads: Array<SignablePayload>;
};

export type Signable = Entity & {
  __typename: 'Signable';
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

export type SignablePayload = Entity & {
  __typename: 'SignablePayload';
  /** The tweak value to add. */
  add_tweak?: Maybe<Scalars['Hash32']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The consistent method for generating the same set of accounts and wallets for a given private key */
  derivation_path: Scalars['String'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The tweak value to multiply. */
  mul_tweak?: Maybe<Scalars['Hash32']>;
  /** The payload that needs to be signed. */
  payload: Scalars['String'];
  /** The signable this payload belongs to. */
  signable: Signable;
  /** The status of the payload. */
  status: SignablePayloadStatus;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

export enum SignablePayloadStatus {
  Created = 'CREATED',
  Signed = 'SIGNED'
}

export type Signature = {
  id: Scalars['ID'];
  signature: Scalars['String'];
};

/** This is a Sparknode. */
export type Sparknode = {
  /** The addresses that this node has announced for itself on the Lightning Network. */
  addresses: NodeToAddressesConnection;
  /** A name that identifies the node. It has no importance in terms of operating the node, it is just a way to identify and search for commercial services or popular nodes. This alias can be changed at any time by the node operator. */
  alias?: Maybe<Scalars['String']>;
  /** The Bitcoin Network this node is deployed in. */
  bitcoin_network: BitcoinNetwork;
  /** The details of the balance of this node on the Bitcoin Network. */
  blockchain_balance?: Maybe<BlockchainBalance>;
  /** The channels that are connected to this node. */
  channels: LightsparkNodeToChannelsConnection;
  /** A hexadecimal string that describes a color. For example "#000000" is black, "#FFFFFF" is white. It has no importance in terms of operating the node, it is just a way to visually differentiate nodes. That color can be changed at any time by the node operator. */
  color?: Maybe<Scalars['String']>;
  /** A summary metric used to capture how well positioned a node is to send, receive, or route transactions efficiently. Maximizing a node's conductivity helps a node’s transactions to be capital efficient. The value is an integer ranging between 0 and 10 (bounds included). */
  conductivity?: Maybe<Scalars['Int']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The name of this node in the network. It will be the most human-readable option possible, depending on the data available for this node. */
  display_name: Scalars['String'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The sum of the channel balances (online only) that are available to send on this node. */
  local_balance?: Maybe<CurrencyAmount>;
  /** The owner of this LightsparkNode. */
  owner: LightsparkNodeOwner;
  /** The public key of this node. It acts as a unique identifier of this node in the Lightning Network. */
  public_key?: Maybe<Scalars['String']>;
  /** The sum of the channel balances that are available to receive on this node. */
  remote_balance?: Maybe<CurrencyAmount>;
  /** The current status of this node. */
  status?: Maybe<LightsparkNodeStatus>;
  /** The sum of the balance on the Bitcoin Network, channel balances, and commit fees on this node. */
  total_balance?: Maybe<CurrencyAmount>;
  /** The total sum of the channel balances (online and offline) on this node. */
  total_local_balance?: Maybe<CurrencyAmount>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This is a Sparknode. */
export type SparknodeAddressesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<NodeAddressType>>;
};


/** This is a Sparknode. */
export type SparknodeChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<ChannelStatus>>;
};

export type Subscription = {
  __typename: 'Subscription';
  entity: Entity;
  transactions: Transaction;
};


export type SubscriptionEntityArgs = {
  id: Scalars['ID'];
};


export type SubscriptionTransactionsArgs = {
  node_ids: Array<Scalars['ID']>;
};

/** This object represents a payment transaction. The transaction can occur either on a Bitcoin Network, or over the Lightning Network. You can retrieve this object to receive specific information about a particular transaction tied to your Lightspark Node. */
export type Transaction = {
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This object represents payment failures associated with your Lightspark Node. */
export type TransactionFailures = {
  payment_failures?: InputMaybe<Array<PaymentFailureReason>>;
  routing_transaction_failures?: InputMaybe<Array<RoutingTransactionFailureReason>>;
};

/** This is an enum of the potential statuses a transaction associated with your Lightspark Node can take. */
export enum TransactionStatus {
  /**
   * For transaction type PAYMENT_REQUEST only.
   * @deprecated Transaction type PAYMENT_REQUEST is deprecated.
   */
  Cancelled = 'CANCELLED',
  /**
   * For transaction type PAYMENT_REQUEST only. A payment request has expired.
   * @deprecated Transaction type PAYMENT_REQUEST is deprecated.
   */
  Expired = 'EXPIRED',
  /** Transaction failed. */
  Failed = 'FAILED',
  /**
   * For transaction type PAYMENT_REQUEST only. No payments have been made to a payment request.
   * @deprecated Use `PENDING` instead.
   */
  NotStarted = 'NOT_STARTED',
  /** Transaction has been initiated and is currently in-flight. */
  Pending = 'PENDING',
  /** Transaction succeeded.. */
  Success = 'SUCCESS'
}

/** This is an enum of the potential types of transactions that can be associated with your Lightspark Node. */
export enum TransactionType {
  /** Transactions on Bitcoin blockchain to close a channel on Lightning Network where the balances are allocated back to local and remote nodes. */
  ChannelClose = 'CHANNEL_CLOSE',
  /** Transactions on Bitcoin blockchain to open a channel on Lightning Network funded by the local Lightspark node. */
  ChannelOpen = 'CHANNEL_OPEN',
  /** Transactions received by a Lightspark node on Lightning Network. */
  IncomingPayment = 'INCOMING_PAYMENT',
  /** Transactions on Bitcoin blockchain to fund a Lightspark node's wallet. */
  L1Deposit = 'L1_DEPOSIT',
  /** Transactions on the Bitcoin blockchain to withdraw funds from a Lightspark node to a Bitcoin wallet. */
  L1Withdraw = 'L1_WITHDRAW',
  /** Transactions initiated from a Lightspark node on Lightning Network. */
  OutgoingPayment = 'OUTGOING_PAYMENT',
  /**
   * Transactions initiated from a Lightspark node on Lightning Network.
   * @deprecated Use OUTGOING_PAYMENT instead.
   */
  Payment = 'PAYMENT',
  /**
   * Payment requests from a Lightspark node on Lightning Network
   * @deprecated Use INCOMING_PAYMENT for received payments. To query payment requests, use payment_requests on Account.
   */
  PaymentRequest = 'PAYMENT_REQUEST',
  /**
   * Transactions that forwarded payments through Lightspark nodes on Lightning Network.
   * @deprecated Use ROUTED instead.
   */
  Route = 'ROUTE',
  /** Transactions that forwarded payments through Lightspark nodes on Lightning Network. */
  Routed = 'ROUTED'
}

export type UpdateChannelPerCommitmentPointInput = {
  channel_id: Scalars['ID'];
  per_commitment_point: Scalars['PublicKey'];
};

export type UpdateChannelPerCommitmentPointOutput = {
  __typename: 'UpdateChannelPerCommitmentPointOutput';
  channel: Channel;
};

export type UpdateNodeSharedSecretInput = {
  node_id: Scalars['ID'];
  shared_secret: Scalars['Hash32'];
};

export type UpdateNodeSharedSecretOutput = {
  __typename: 'UpdateNodeSharedSecretOutput';
  node: LightsparkNode;
};

/** This object represents a Lightspark Wallet, tied to your Lightspark account. Wallets can be used to send or receive funds over the Lightning Network. You can retrieve this object to receive information about a specific wallet tied to your Lightspark account. */
export type Wallet = Entity & LightsparkNodeOwner & {
  __typename: 'Wallet';
  /** The balances that describe the funds in this wallet. */
  balances?: Maybe<Balances>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The date and time when the wallet user last logged in. */
  last_login_at?: Maybe<Scalars['DateTime']>;
  /** The status of this wallet. */
  status: WalletStatus;
  /** The unique identifier of this wallet, as provided by the Lightspark Customer during login. */
  third_party_identifier: Scalars['String'];
  /** The total amount received in this wallet on Lightning Network within given time period. */
  total_amount_received: CurrencyAmount;
  /** The total amount sent in this wallet on Lightning Network within given time period. */
  total_amount_sent: CurrencyAmount;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};


/** This object represents a Lightspark Wallet, tied to your Lightspark account. Wallets can be used to send or receive funds over the Lightning Network. You can retrieve this object to receive information about a specific wallet tied to your Lightspark account. */
export type WalletTotal_Amount_ReceivedArgs = {
  created_after_date?: InputMaybe<Scalars['DateTime']>;
  created_before_date?: InputMaybe<Scalars['DateTime']>;
};


/** This object represents a Lightspark Wallet, tied to your Lightspark account. Wallets can be used to send or receive funds over the Lightning Network. You can retrieve this object to receive information about a specific wallet tied to your Lightspark account. */
export type WalletTotal_Amount_SentArgs = {
  created_after_date?: InputMaybe<Scalars['DateTime']>;
  created_before_date?: InputMaybe<Scalars['DateTime']>;
};

/** This is an enum of the potential statuses that your Lightspark wallet can take.  */
export enum WalletStatus {
  /** The wallet has been deployed in the Lightspark infrastructure and is ready to be initialized. */
  Deployed = 'DEPLOYED',
  /** The wallet is currently being deployed in the Lightspark infrastructure. */
  Deploying = 'DEPLOYING',
  /** The wallet had an unrecoverable failure. This status is not expected to happend and will be investigated by the Lightspark team. */
  Failed = 'FAILED',
  /** The wallet is currently being initialized. */
  Initializing = 'INITIALIZING',
  /** The wallet has not been set up yet and is ready to be deployed. This is the default status after the first login. */
  NotSetup = 'NOT_SETUP',
  /** The wallet is available and ready to be used. */
  Ready = 'READY',
  /** The wallet has been terminated and is not available in the Lightspark infrastructure anymore. It is not connected to the Lightning network and its funds can only be accessed using the Funds Recovery flow. */
  Terminated = 'TERMINATED',
  /** The wallet is being terminated. */
  Terminating = 'TERMINATING',
  /** The wallet is temporarily available, due to a transient issue or a scheduled maintenance. */
  Unavailable = 'UNAVAILABLE'
}

/** This is an enum of the potential event types that can be associated with your Lightspark wallets. */
export enum WebhookEventType {
  NodeStatus = 'NODE_STATUS',
  PaymentFinished = 'PAYMENT_FINISHED',
  RemoteSigning = 'REMOTE_SIGNING',
  WalletFundsReceived = 'WALLET_FUNDS_RECEIVED',
  WalletIncomingPaymentFinished = 'WALLET_INCOMING_PAYMENT_FINISHED',
  WalletOutgoingPaymentFinished = 'WALLET_OUTGOING_PAYMENT_FINISHED',
  WalletStatus = 'WALLET_STATUS',
  WalletWithdrawalFinished = 'WALLET_WITHDRAWAL_FINISHED'
}

/** This object represents an L1 withdrawal from your Lightspark Node to any Bitcoin wallet. You can retrieve this object to receive detailed information about any L1 withdrawal associated with your Lightspark Node or account. */
export type Withdrawal = Entity & OnChainTransaction & Transaction & {
  __typename: 'Withdrawal';
  /** The amount of money involved in this transaction. */
  amount: CurrencyAmount;
  /** The hash of the block that included this transaction. This will be null for unconfirmed transactions. */
  block_hash?: Maybe<Scalars['String']>;
  /** The height of the block that included this transaction. This will be zero for unconfirmed transactions. */
  block_height: Scalars['Int'];
  /** The date and time when this transaction was initiated. */
  created_at: Scalars['DateTime'];
  /** The Bitcoin blockchain addresses this transaction was sent to. */
  destination_addresses: Array<Scalars['String']>;
  /** The fees that were paid by the wallet sending the transaction to commit it to the Bitcoin blockchain. */
  fees?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The number of blockchain confirmations for this transaction in real time. */
  num_confirmations?: Maybe<Scalars['Int']>;
  /** The Lightspark node this withdrawal originated from. */
  origin: LightsparkNode;
  /** The date and time when this transaction was completed or failed. */
  resolved_at?: Maybe<Scalars['DateTime']>;
  /** The current status of this transaction. */
  status: TransactionStatus;
  /** The hash of this transaction, so it can be uniquely identified on the Lightning Network. */
  transaction_hash?: Maybe<Scalars['String']>;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
};

/** This is an enum of the potential modes that your Bitcoin withdrawal can take. */
export enum WithdrawalMode {
  WalletOnly = 'WALLET_ONLY',
  WalletThenChannels = 'WALLET_THEN_CHANNELS'
}

/** This object represents a request made for an L1 withdrawal from your Lightspark Node to any Bitcoin wallet. You can retrieve this object to receive detailed information about any withdrawal request made from your Lightspark account. */
export type WithdrawalRequest = Entity & {
  __typename: 'WithdrawalRequest';
  /** The amount of money that should be withdrawn in this request. */
  amount: CurrencyAmount;
  /** The bitcoin address where the funds should be sent. */
  bitcoin_address: Scalars['String'];
  /** The transactions that have been generated when closing channels to fulfill this withdrawal. */
  channel_closing_transactions: WithdrawalRequestToChannelClosingTransactionsConnection;
  /** The transactions that have been generated when opening channels to fulfill this withdrawal. */
  channel_opening_transactions: WithdrawalRequestToChannelOpeningTransactionsConnection;
  /** The time at which this request was completed. */
  completed_at?: Maybe<Scalars['DateTime']>;
  /** The date and time when the entity was first created. */
  created_at: Scalars['DateTime'];
  /** If the requested amount is `-1` (i.e. everything), this field may contain an estimate of the amount for the withdrawal. */
  estimated_amount?: Maybe<CurrencyAmount>;
  /** The unique identifier of this entity across all Lightspark systems. Should be treated as an opaque string. */
  id: Scalars['ID'];
  /** The current status of this withdrawal request. */
  status: WithdrawalRequestStatus;
  /** The date and time when the entity was last updated. */
  updated_at: Scalars['DateTime'];
  /** The withdrawal transaction that has been generated by this request. */
  withdrawal?: Maybe<Withdrawal>;
  /** The strategy that should be used to withdraw the funds from the account. */
  withdrawal_mode: WithdrawalMode;
};


/** This object represents a request made for an L1 withdrawal from your Lightspark Node to any Bitcoin wallet. You can retrieve this object to receive detailed information about any withdrawal request made from your Lightspark account. */
export type WithdrawalRequestChannel_Closing_TransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** This object represents a request made for an L1 withdrawal from your Lightspark Node to any Bitcoin wallet. You can retrieve this object to receive detailed information about any withdrawal request made from your Lightspark account. */
export type WithdrawalRequestChannel_Opening_TransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};

/** This is an enum of the potential statuses that a Withdrawal can take. */
export enum WithdrawalRequestStatus {
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Successful = 'SUCCESSFUL'
}

export type WithdrawalRequestToChannelClosingTransactionsConnection = {
  __typename: 'WithdrawalRequestToChannelClosingTransactionsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The channel closing transactions for the current page of this connection. */
  entities: Array<ChannelClosingTransaction>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
};

export type WithdrawalRequestToChannelOpeningTransactionsConnection = {
  __typename: 'WithdrawalRequestToChannelOpeningTransactionsConnection';
  /** The total count of objects in this connection, using the current filters. It is different from the number of objects returned in the current page (in the `entities` field). */
  count: Scalars['Int'];
  /** The channel opening transactions for the current page of this connection. */
  entities: Array<ChannelOpeningTransaction>;
  /** An object that holds pagination information about the objects in this connection. */
  page_info: PageInfo;
};

export type TransactionsForNodeQueryVariables = Exact<{
  network: BitcoinNetwork;
  nodeId: Scalars['ID'];
  numTransactions?: InputMaybe<Scalars['Int']>;
  afterDate?: InputMaybe<Scalars['DateTime']>;
  transactionTypes?: InputMaybe<Array<TransactionType> | TransactionType>;
  transaction_statuses?: InputMaybe<Array<TransactionStatus> | TransactionStatus>;
}>;


export type TransactionsForNodeQuery = { __typename: 'Query', current_account?: { __typename: 'Account', id: string, name?: string | null, recent_transactions: { __typename: 'AccountToTransactionsConnection', count: number, total_amount_transacted?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, entities: Array<{ __typename: 'ChannelClosingTransaction', channel_closing_transaction_id: string, channel_closing_transaction_created_at: any, channel_closing_transaction_updated_at: any, channel_closing_transaction_status: TransactionStatus, channel_closing_transaction_resolved_at?: any | null, channel_closing_transaction_transaction_hash?: string | null, channel_closing_transaction_block_hash?: string | null, channel_closing_transaction_block_height: number, channel_closing_transaction_destination_addresses: Array<string>, channel_closing_transaction_num_confirmations?: number | null, channel_closing_transaction_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, channel_closing_transaction_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, channel_closing_transaction_channel?: { __typename: 'Channel', id: string } | null } | { __typename: 'ChannelOpeningTransaction', channel_opening_transaction_id: string, channel_opening_transaction_created_at: any, channel_opening_transaction_updated_at: any, channel_opening_transaction_status: TransactionStatus, channel_opening_transaction_resolved_at?: any | null, channel_opening_transaction_transaction_hash?: string | null, channel_opening_transaction_block_hash?: string | null, channel_opening_transaction_block_height: number, channel_opening_transaction_destination_addresses: Array<string>, channel_opening_transaction_num_confirmations?: number | null, channel_opening_transaction_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, channel_opening_transaction_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, channel_opening_transaction_channel?: { __typename: 'Channel', id: string } | null } | { __typename: 'Deposit', deposit_id: string, deposit_created_at: any, deposit_updated_at: any, deposit_status: TransactionStatus, deposit_resolved_at?: any | null, deposit_transaction_hash?: string | null, deposit_block_hash?: string | null, deposit_block_height: number, deposit_destination_addresses: Array<string>, deposit_num_confirmations?: number | null, deposit_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, deposit_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, deposit_destination: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string } } | { __typename: 'IncomingPayment', incoming_payment_id: string, incoming_payment_created_at: any, incoming_payment_updated_at: any, incoming_payment_status: TransactionStatus, incoming_payment_resolved_at?: any | null, incoming_payment_transaction_hash?: string | null, incoming_payment_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, incoming_payment_destination: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string }, incoming_payment_payment_request?: { __typename: 'Invoice', id: string } | null } | { __typename: 'OutgoingPayment', outgoing_payment_id: string, outgoing_payment_created_at: any, outgoing_payment_updated_at: any, outgoing_payment_status: TransactionStatus, outgoing_payment_resolved_at?: any | null, outgoing_payment_transaction_hash?: string | null, outgoing_payment_failure_reason?: PaymentFailureReason | null, outgoing_payment_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, outgoing_payment_origin: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string }, outgoing_payment_destination?: { __typename: 'GraphNode', id: string } | { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string } | null, outgoing_payment_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, outgoing_payment_payment_request_data?: { __typename: 'InvoiceData', invoice_data_encoded_payment_request: string, invoice_data_bitcoin_network: BitcoinNetwork, invoice_data_payment_hash: string, invoice_data_created_at: any, invoice_data_expires_at: any, invoice_data_memo?: string | null, invoice_data_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, invoice_data_destination: { __typename: 'GraphNode', graph_node_id: string, graph_node_created_at: any, graph_node_updated_at: any, graph_node_alias?: string | null, graph_node_bitcoin_network: BitcoinNetwork, graph_node_color?: string | null, graph_node_conductivity?: number | null, graph_node_display_name: string, graph_node_public_key?: string | null } | { __typename: 'LightsparkNodeWithOSKLND', lightspark_node_id: string, lightspark_node_created_at: any, lightspark_node_updated_at: any, lightspark_node_alias?: string | null, lightspark_node_bitcoin_network: BitcoinNetwork, lightspark_node_color?: string | null, lightspark_node_conductivity?: number | null, lightspark_node_display_name: string, lightspark_node_public_key?: string | null, lightspark_node_status?: LightsparkNodeStatus | null, lightspark_node_owner: { __typename: 'Account', id: string } | { __typename: 'Wallet', id: string }, lightspark_node_total_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_total_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null } | { __typename: 'LightsparkNodeWithOSKSparknode', lightspark_node_id: string, lightspark_node_created_at: any, lightspark_node_updated_at: any, lightspark_node_alias?: string | null, lightspark_node_bitcoin_network: BitcoinNetwork, lightspark_node_color?: string | null, lightspark_node_conductivity?: number | null, lightspark_node_display_name: string, lightspark_node_public_key?: string | null, lightspark_node_status?: LightsparkNodeStatus | null, lightspark_node_owner: { __typename: 'Account', id: string } | { __typename: 'Wallet', id: string }, lightspark_node_total_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_total_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null } | { __typename: 'LightsparkNodeWithServerSigning', lightspark_node_id: string, lightspark_node_created_at: any, lightspark_node_updated_at: any, lightspark_node_alias?: string | null, lightspark_node_bitcoin_network: BitcoinNetwork, lightspark_node_color?: string | null, lightspark_node_conductivity?: number | null, lightspark_node_display_name: string, lightspark_node_public_key?: string | null, lightspark_node_status?: LightsparkNodeStatus | null, lightspark_node_owner: { __typename: 'Account', id: string } | { __typename: 'Wallet', id: string }, lightspark_node_total_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_total_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null } } | null, outgoing_payment_failure_message?: { __typename: 'RichText', rich_text_text: string } | null } | { __typename: 'RoutingTransaction', routing_transaction_id: string, routing_transaction_created_at: any, routing_transaction_updated_at: any, routing_transaction_status: TransactionStatus, routing_transaction_resolved_at?: any | null, routing_transaction_transaction_hash?: string | null, routing_transaction_failure_reason?: RoutingTransactionFailureReason | null, routing_transaction_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, routing_transaction_incoming_channel?: { __typename: 'Channel', id: string } | null, routing_transaction_outgoing_channel?: { __typename: 'Channel', id: string } | null, routing_transaction_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, routing_transaction_failure_message?: { __typename: 'RichText', rich_text_text: string } | null } | { __typename: 'Withdrawal', withdrawal_id: string, withdrawal_created_at: any, withdrawal_updated_at: any, withdrawal_status: TransactionStatus, withdrawal_resolved_at?: any | null, withdrawal_transaction_hash?: string | null, withdrawal_block_hash?: string | null, withdrawal_block_height: number, withdrawal_destination_addresses: Array<string>, withdrawal_num_confirmations?: number | null, withdrawal_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, withdrawal_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, withdrawal_origin: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string } }> } } | null };

type TransactionFragment_ChannelClosingTransaction_Fragment = { __typename: 'ChannelClosingTransaction', channel_closing_transaction_id: string, channel_closing_transaction_created_at: any, channel_closing_transaction_updated_at: any, channel_closing_transaction_status: TransactionStatus, channel_closing_transaction_resolved_at?: any | null, channel_closing_transaction_transaction_hash?: string | null, channel_closing_transaction_block_hash?: string | null, channel_closing_transaction_block_height: number, channel_closing_transaction_destination_addresses: Array<string>, channel_closing_transaction_num_confirmations?: number | null, channel_closing_transaction_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, channel_closing_transaction_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, channel_closing_transaction_channel?: { __typename: 'Channel', id: string } | null };

type TransactionFragment_ChannelOpeningTransaction_Fragment = { __typename: 'ChannelOpeningTransaction', channel_opening_transaction_id: string, channel_opening_transaction_created_at: any, channel_opening_transaction_updated_at: any, channel_opening_transaction_status: TransactionStatus, channel_opening_transaction_resolved_at?: any | null, channel_opening_transaction_transaction_hash?: string | null, channel_opening_transaction_block_hash?: string | null, channel_opening_transaction_block_height: number, channel_opening_transaction_destination_addresses: Array<string>, channel_opening_transaction_num_confirmations?: number | null, channel_opening_transaction_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, channel_opening_transaction_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, channel_opening_transaction_channel?: { __typename: 'Channel', id: string } | null };

type TransactionFragment_Deposit_Fragment = { __typename: 'Deposit', deposit_id: string, deposit_created_at: any, deposit_updated_at: any, deposit_status: TransactionStatus, deposit_resolved_at?: any | null, deposit_transaction_hash?: string | null, deposit_block_hash?: string | null, deposit_block_height: number, deposit_destination_addresses: Array<string>, deposit_num_confirmations?: number | null, deposit_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, deposit_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, deposit_destination: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string } };

type TransactionFragment_IncomingPayment_Fragment = { __typename: 'IncomingPayment', incoming_payment_id: string, incoming_payment_created_at: any, incoming_payment_updated_at: any, incoming_payment_status: TransactionStatus, incoming_payment_resolved_at?: any | null, incoming_payment_transaction_hash?: string | null, incoming_payment_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, incoming_payment_destination: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string }, incoming_payment_payment_request?: { __typename: 'Invoice', id: string } | null };

type TransactionFragment_OutgoingPayment_Fragment = { __typename: 'OutgoingPayment', outgoing_payment_id: string, outgoing_payment_created_at: any, outgoing_payment_updated_at: any, outgoing_payment_status: TransactionStatus, outgoing_payment_resolved_at?: any | null, outgoing_payment_transaction_hash?: string | null, outgoing_payment_failure_reason?: PaymentFailureReason | null, outgoing_payment_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, outgoing_payment_origin: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string }, outgoing_payment_destination?: { __typename: 'GraphNode', id: string } | { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string } | null, outgoing_payment_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, outgoing_payment_payment_request_data?: { __typename: 'InvoiceData', invoice_data_encoded_payment_request: string, invoice_data_bitcoin_network: BitcoinNetwork, invoice_data_payment_hash: string, invoice_data_created_at: any, invoice_data_expires_at: any, invoice_data_memo?: string | null, invoice_data_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, invoice_data_destination: { __typename: 'GraphNode', graph_node_id: string, graph_node_created_at: any, graph_node_updated_at: any, graph_node_alias?: string | null, graph_node_bitcoin_network: BitcoinNetwork, graph_node_color?: string | null, graph_node_conductivity?: number | null, graph_node_display_name: string, graph_node_public_key?: string | null } | { __typename: 'LightsparkNodeWithOSKLND', lightspark_node_id: string, lightspark_node_created_at: any, lightspark_node_updated_at: any, lightspark_node_alias?: string | null, lightspark_node_bitcoin_network: BitcoinNetwork, lightspark_node_color?: string | null, lightspark_node_conductivity?: number | null, lightspark_node_display_name: string, lightspark_node_public_key?: string | null, lightspark_node_status?: LightsparkNodeStatus | null, lightspark_node_owner: { __typename: 'Account', id: string } | { __typename: 'Wallet', id: string }, lightspark_node_total_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_total_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null } | { __typename: 'LightsparkNodeWithOSKSparknode', lightspark_node_id: string, lightspark_node_created_at: any, lightspark_node_updated_at: any, lightspark_node_alias?: string | null, lightspark_node_bitcoin_network: BitcoinNetwork, lightspark_node_color?: string | null, lightspark_node_conductivity?: number | null, lightspark_node_display_name: string, lightspark_node_public_key?: string | null, lightspark_node_status?: LightsparkNodeStatus | null, lightspark_node_owner: { __typename: 'Account', id: string } | { __typename: 'Wallet', id: string }, lightspark_node_total_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_total_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null } | { __typename: 'LightsparkNodeWithServerSigning', lightspark_node_id: string, lightspark_node_created_at: any, lightspark_node_updated_at: any, lightspark_node_alias?: string | null, lightspark_node_bitcoin_network: BitcoinNetwork, lightspark_node_color?: string | null, lightspark_node_conductivity?: number | null, lightspark_node_display_name: string, lightspark_node_public_key?: string | null, lightspark_node_status?: LightsparkNodeStatus | null, lightspark_node_owner: { __typename: 'Account', id: string } | { __typename: 'Wallet', id: string }, lightspark_node_total_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_total_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, lightspark_node_local_balance?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null } } | null, outgoing_payment_failure_message?: { __typename: 'RichText', rich_text_text: string } | null };

type TransactionFragment_RoutingTransaction_Fragment = { __typename: 'RoutingTransaction', routing_transaction_id: string, routing_transaction_created_at: any, routing_transaction_updated_at: any, routing_transaction_status: TransactionStatus, routing_transaction_resolved_at?: any | null, routing_transaction_transaction_hash?: string | null, routing_transaction_failure_reason?: RoutingTransactionFailureReason | null, routing_transaction_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, routing_transaction_incoming_channel?: { __typename: 'Channel', id: string } | null, routing_transaction_outgoing_channel?: { __typename: 'Channel', id: string } | null, routing_transaction_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, routing_transaction_failure_message?: { __typename: 'RichText', rich_text_text: string } | null };

type TransactionFragment_Withdrawal_Fragment = { __typename: 'Withdrawal', withdrawal_id: string, withdrawal_created_at: any, withdrawal_updated_at: any, withdrawal_status: TransactionStatus, withdrawal_resolved_at?: any | null, withdrawal_transaction_hash?: string | null, withdrawal_block_hash?: string | null, withdrawal_block_height: number, withdrawal_destination_addresses: Array<string>, withdrawal_num_confirmations?: number | null, withdrawal_amount: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number }, withdrawal_fees?: { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number } | null, withdrawal_origin: { __typename: 'LightsparkNodeWithOSKLND', id: string } | { __typename: 'LightsparkNodeWithOSKSparknode', id: string } | { __typename: 'LightsparkNodeWithServerSigning', id: string } };

export type TransactionFragmentFragment = TransactionFragment_ChannelClosingTransaction_Fragment | TransactionFragment_ChannelOpeningTransaction_Fragment | TransactionFragment_Deposit_Fragment | TransactionFragment_IncomingPayment_Fragment | TransactionFragment_OutgoingPayment_Fragment | TransactionFragment_RoutingTransaction_Fragment | TransactionFragment_Withdrawal_Fragment;

export type CurrencyAmountFragmentFragment = { __typename: 'CurrencyAmount', currency_amount_original_value: any, currency_amount_original_unit: CurrencyUnit, currency_amount_preferred_currency_unit: CurrencyUnit, currency_amount_preferred_currency_value_rounded: any, currency_amount_preferred_currency_value_approx: number };

export type CurrencyAmount_AmountFragment = { __typename: 'CurrencyAmount', original_value: any, original_unit: CurrencyUnit, preferred_currency_unit: CurrencyUnit, preferred_currency_value_rounded: any, preferred_currency_value_approx: number };

export const TransactionFragmentFragmentDoc = gql`
    fragment TransactionFragment on Transaction {
  __typename
  ... on ChannelClosingTransaction {
    __typename
    channel_closing_transaction_id: id
    channel_closing_transaction_created_at: created_at
    channel_closing_transaction_updated_at: updated_at
    channel_closing_transaction_status: status
    channel_closing_transaction_resolved_at: resolved_at
    channel_closing_transaction_amount: amount {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_closing_transaction_transaction_hash: transaction_hash
    channel_closing_transaction_fees: fees {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_closing_transaction_block_hash: block_hash
    channel_closing_transaction_block_height: block_height
    channel_closing_transaction_destination_addresses: destination_addresses
    channel_closing_transaction_num_confirmations: num_confirmations
    channel_closing_transaction_channel: channel {
      id
    }
  }
  ... on ChannelOpeningTransaction {
    __typename
    channel_opening_transaction_id: id
    channel_opening_transaction_created_at: created_at
    channel_opening_transaction_updated_at: updated_at
    channel_opening_transaction_status: status
    channel_opening_transaction_resolved_at: resolved_at
    channel_opening_transaction_amount: amount {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_opening_transaction_transaction_hash: transaction_hash
    channel_opening_transaction_fees: fees {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    channel_opening_transaction_block_hash: block_hash
    channel_opening_transaction_block_height: block_height
    channel_opening_transaction_destination_addresses: destination_addresses
    channel_opening_transaction_num_confirmations: num_confirmations
    channel_opening_transaction_channel: channel {
      id
    }
  }
  ... on Deposit {
    __typename
    deposit_id: id
    deposit_created_at: created_at
    deposit_updated_at: updated_at
    deposit_status: status
    deposit_resolved_at: resolved_at
    deposit_amount: amount {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    deposit_transaction_hash: transaction_hash
    deposit_fees: fees {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    deposit_block_hash: block_hash
    deposit_block_height: block_height
    deposit_destination_addresses: destination_addresses
    deposit_num_confirmations: num_confirmations
    deposit_destination: destination {
      id
    }
  }
  ... on IncomingPayment {
    __typename
    incoming_payment_id: id
    incoming_payment_created_at: created_at
    incoming_payment_updated_at: updated_at
    incoming_payment_status: status
    incoming_payment_resolved_at: resolved_at
    incoming_payment_amount: amount {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    incoming_payment_transaction_hash: transaction_hash
    incoming_payment_destination: destination {
      id
    }
    incoming_payment_payment_request: payment_request {
      id
    }
  }
  ... on OutgoingPayment {
    __typename
    outgoing_payment_id: id
    outgoing_payment_created_at: created_at
    outgoing_payment_updated_at: updated_at
    outgoing_payment_status: status
    outgoing_payment_resolved_at: resolved_at
    outgoing_payment_amount: amount {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    outgoing_payment_transaction_hash: transaction_hash
    outgoing_payment_origin: origin {
      id
    }
    outgoing_payment_destination: destination {
      id
    }
    outgoing_payment_fees: fees {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    outgoing_payment_payment_request_data: payment_request_data {
      __typename
      ... on InvoiceData {
        __typename
        invoice_data_encoded_payment_request: encoded_payment_request
        invoice_data_bitcoin_network: bitcoin_network
        invoice_data_payment_hash: payment_hash
        invoice_data_amount: amount {
          __typename
          currency_amount_original_value: original_value
          currency_amount_original_unit: original_unit
          currency_amount_preferred_currency_unit: preferred_currency_unit
          currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
          currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
        }
        invoice_data_created_at: created_at
        invoice_data_expires_at: expires_at
        invoice_data_memo: memo
        invoice_data_destination: destination {
          __typename
          ... on GraphNode {
            __typename
            graph_node_id: id
            graph_node_created_at: created_at
            graph_node_updated_at: updated_at
            graph_node_alias: alias
            graph_node_bitcoin_network: bitcoin_network
            graph_node_color: color
            graph_node_conductivity: conductivity
            graph_node_display_name: display_name
            graph_node_public_key: public_key
          }
          ... on LightsparkNode {
            __typename
            lightspark_node_id: id
            lightspark_node_created_at: created_at
            lightspark_node_updated_at: updated_at
            lightspark_node_alias: alias
            lightspark_node_bitcoin_network: bitcoin_network
            lightspark_node_color: color
            lightspark_node_conductivity: conductivity
            lightspark_node_display_name: display_name
            lightspark_node_public_key: public_key
            lightspark_node_owner: owner {
              id
            }
            ... on LightsparkNodeWithOSKLND {
              lightspark_node_with_osk_lnd_blockchain_balance: blockchain_balance {
                __typename
                blockchain_balance_total_balance: total_balance {
                  __typename
                  currency_amount_original_value: original_value
                  currency_amount_original_unit: original_unit
                  currency_amount_preferred_currency_unit: preferred_currency_unit
                  currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                  currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
                blockchain_balance_confirmed_balance: confirmed_balance {
                  __typename
                  currency_amount_original_value: original_value
                  currency_amount_original_unit: original_unit
                  currency_amount_preferred_currency_unit: preferred_currency_unit
                  currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                  currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
                blockchain_balance_unconfirmed_balance: unconfirmed_balance {
                  __typename
                  currency_amount_original_value: original_value
                  currency_amount_original_unit: original_unit
                  currency_amount_preferred_currency_unit: preferred_currency_unit
                  currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                  currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
                blockchain_balance_locked_balance: locked_balance {
                  __typename
                  currency_amount_original_value: original_value
                  currency_amount_original_unit: original_unit
                  currency_amount_preferred_currency_unit: preferred_currency_unit
                  currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                  currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
                blockchain_balance_required_reserve: required_reserve {
                  __typename
                  currency_amount_original_value: original_value
                  currency_amount_original_unit: original_unit
                  currency_amount_preferred_currency_unit: preferred_currency_unit
                  currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                  currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
                blockchain_balance_available_balance: available_balance {
                  __typename
                  currency_amount_original_value: original_value
                  currency_amount_original_unit: original_unit
                  currency_amount_preferred_currency_unit: preferred_currency_unit
                  currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                  currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
                }
              }
              lightspark_node_with_osk_lnd_encrypted_signing_private_key: encrypted_signing_private_key {
                __typename
                secret_encrypted_value: encrypted_value
                secret_cipher: cipher
              }
              lightspark_node_with_osk_lnd_remote_balance: remote_balance {
                __typename
                currency_amount_original_value: original_value
                currency_amount_original_unit: original_unit
                currency_amount_preferred_currency_unit: preferred_currency_unit
                currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
                currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
              }
            }
            lightspark_node_total_balance: total_balance {
              __typename
              currency_amount_original_value: original_value
              currency_amount_original_unit: original_unit
              currency_amount_preferred_currency_unit: preferred_currency_unit
              currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
              currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            lightspark_node_total_local_balance: total_local_balance {
              __typename
              currency_amount_original_value: original_value
              currency_amount_original_unit: original_unit
              currency_amount_preferred_currency_unit: preferred_currency_unit
              currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
              currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            lightspark_node_local_balance: local_balance {
              __typename
              currency_amount_original_value: original_value
              currency_amount_original_unit: original_unit
              currency_amount_preferred_currency_unit: preferred_currency_unit
              currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
              currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
            }
            lightspark_node_status: status
          }
        }
      }
    }
    outgoing_payment_failure_reason: failure_reason
    outgoing_payment_failure_message: failure_message {
      __typename
      rich_text_text: text
    }
  }
  ... on RoutingTransaction {
    __typename
    routing_transaction_id: id
    routing_transaction_created_at: created_at
    routing_transaction_updated_at: updated_at
    routing_transaction_status: status
    routing_transaction_resolved_at: resolved_at
    routing_transaction_amount: amount {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    routing_transaction_transaction_hash: transaction_hash
    routing_transaction_incoming_channel: incoming_channel {
      id
    }
    routing_transaction_outgoing_channel: outgoing_channel {
      id
    }
    routing_transaction_fees: fees {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    routing_transaction_failure_message: failure_message {
      __typename
      rich_text_text: text
    }
    routing_transaction_failure_reason: failure_reason
  }
  ... on Withdrawal {
    __typename
    withdrawal_id: id
    withdrawal_created_at: created_at
    withdrawal_updated_at: updated_at
    withdrawal_status: status
    withdrawal_resolved_at: resolved_at
    withdrawal_amount: amount {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_transaction_hash: transaction_hash
    withdrawal_fees: fees {
      __typename
      currency_amount_original_value: original_value
      currency_amount_original_unit: original_unit
      currency_amount_preferred_currency_unit: preferred_currency_unit
      currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
      currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
    }
    withdrawal_block_hash: block_hash
    withdrawal_block_height: block_height
    withdrawal_destination_addresses: destination_addresses
    withdrawal_num_confirmations: num_confirmations
    withdrawal_origin: origin {
      id
    }
  }
}
    `;
export const CurrencyAmountFragmentFragmentDoc = gql`
    fragment CurrencyAmountFragment on CurrencyAmount {
  __typename
  currency_amount_original_value: original_value
  currency_amount_original_unit: original_unit
  currency_amount_preferred_currency_unit: preferred_currency_unit
  currency_amount_preferred_currency_value_rounded: preferred_currency_value_rounded
  currency_amount_preferred_currency_value_approx: preferred_currency_value_approx
}
    `;
export const CurrencyAmount_AmountFragmentDoc = gql`
    fragment CurrencyAmount_amount on CurrencyAmount {
  original_value
  original_unit
  preferred_currency_unit
  preferred_currency_value_rounded
  preferred_currency_value_approx
}
    `;
export const TransactionsForNodeDocument = gql`
    query TransactionsForNode($network: BitcoinNetwork!, $nodeId: ID!, $numTransactions: Int, $afterDate: DateTime, $transactionTypes: [TransactionType!] = [PAYMENT, PAYMENT_REQUEST, ROUTE, L1_WITHDRAW, L1_DEPOSIT], $transaction_statuses: [TransactionStatus!] = null) {
  current_account {
    id
    name
    recent_transactions: transactions(
      first: $numTransactions
      types: $transactionTypes
      bitcoin_network: $network
      lightning_node_id: $nodeId
      statuses: $transaction_statuses
      after_date: $afterDate
    ) {
      count
      total_amount_transacted {
        ...CurrencyAmountFragment
      }
      entities {
        ...TransactionFragment
        __typename
      }
      __typename
    }
    __typename
  }
}
    ${CurrencyAmountFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;

/**
 * __useTransactionsForNodeQuery__
 *
 * To run a query within a React component, call `useTransactionsForNodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionsForNodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionsForNodeQuery({
 *   variables: {
 *      network: // value for 'network'
 *      nodeId: // value for 'nodeId'
 *      numTransactions: // value for 'numTransactions'
 *      afterDate: // value for 'afterDate'
 *      transactionTypes: // value for 'transactionTypes'
 *      transaction_statuses: // value for 'transaction_statuses'
 *   },
 * });
 */
export function useTransactionsForNodeQuery(baseOptions: Apollo.QueryHookOptions<TransactionsForNodeQuery, TransactionsForNodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TransactionsForNodeQuery, TransactionsForNodeQueryVariables>(TransactionsForNodeDocument, options);
      }
export function useTransactionsForNodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TransactionsForNodeQuery, TransactionsForNodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TransactionsForNodeQuery, TransactionsForNodeQueryVariables>(TransactionsForNodeDocument, options);
        }
export type TransactionsForNodeQueryHookResult = ReturnType<typeof useTransactionsForNodeQuery>;
export type TransactionsForNodeLazyQueryHookResult = ReturnType<typeof useTransactionsForNodeLazyQuery>;
export type TransactionsForNodeQueryResult = Apollo.QueryResult<TransactionsForNodeQuery, TransactionsForNodeQueryVariables>;