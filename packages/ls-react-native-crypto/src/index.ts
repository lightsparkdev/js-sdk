import { b64decode, b64encode } from "./base64";
import LightsparkdevReactNativeCryptoModule from "./LightsparkdevReactNativeCryptoModule";

export { b64decode, b64encode };

/**
 * A representation of a key pair generated by the native crypto module.
 *
 * @typedef {Object} ExportedKeys
 * @property {ExportedKey} privateKey The private key of the key pair.
 * @property {ExportedKey} publicKey The public key of the key pair.
 * @property {string} alias The alias of the key pair in the native keystore. This is used to retrieve the key pair
 *     for signing, etc.
 */
export type ExportedKeys = {
  privateKey: ExportedKey;
  publicKey: ExportedKey;
  alias: string;
};

/**
 * A representation of a key generated by the native crypto module.
 * @typedef {Object} ExportedKey
 * @property {string} keyBytes The base64 representation of the key.
 * @property {KeyEncodingFormat} format The format of the key.
 */
export type ExportedKey = {
  keyBytes: string;
  format: KeyEncodingFormat;
};

/**
 * The encoding format of a key.
 */
export type KeyEncodingFormat = "pkcs8" | "spki" | "pkcs1";

/**
 * A representation of a mnemonic generated by the native crypto module.
 * @typedef {Object} Mnemonic
 * @property {string} phrase The mnemonic string separated by spaces.
 */
export type Mnemonic = {
  phrase: string;
};

/**
 * A representation of a seed generated by the native crypto module.
 * @typedef {Object} Seed
 * @property {string} seedBytes The seed raw bytes in base64-encoded format.
 */
export type Seed = {
  seedBytes: string;
};

/**
 * Generate a key pair for signing and ensures that the private key is stored in the native keystore.
 * After running this function, the alias in the {@link ExportedKeys.alias} property of the returned object can be
 * used to signing messages.
 *
 * You likely want to store the alias in a a persistent local store (like AsyncStorage) so that you can use it later.
 *
 * @returns {Promise<ExportedKeys>} A promise that resolves to an object containing the public and private keys, along
 *     with an alias for the key pair.
 */
export async function generateSigningKeyPair(): Promise<ExportedKeys> {
  return await LightsparkdevReactNativeCryptoModule.generateSigningKeyPair();
}

/**
 * Exports the raw byes of the key pair with the given alias. This should only be used for
 * debugging purposes or for backing up the key pair. Do not keep these bytes in memory for
 * longer than necessary.
 *
 * @param keyAlias The alias of the key to export.
 * @returns {Promise<ExportedKeys>} A promise that resolves to an object containing the public and private keys.
 */
export async function serializeSigningKey(
  keyAlias: string,
): Promise<ExportedKeys> {
  return await LightsparkdevReactNativeCryptoModule.serializeSigningKey(
    keyAlias,
  );
}

/**
 * Imports a private key into the native keystore.
 *
 * You likely want to store the returned alias in a a persistent local store (like AsyncStorage) so that you can use
 * it later.
 *
 * NOTE: iOS can only import pkcs1 format private keys! Other formats will fail. However, if you're just importing a
 * key that was generated by this native crypto module, it will be in the correct format.
 *
 * @param keyData The raw bytes of the private key to import.
 * @returns {Promise<string>} A promise that resolves to the alias of the imported key pair that can be used to sign
 *     messages.
 */
export async function importPrivateSigningKey(
  keyData: string,
): Promise<string> {
  return await LightsparkdevReactNativeCryptoModule.importPrivateSigningKey(
    keyData,
  );
}

/**
 * Signs the given data using the private key represented by the given alias.
 *
 * @param keyAlias The alias of the key pair to use for signing.
 * @param data The data to sign in base64 encoded format.
 * @returns {Promise<string>} A promise that resolves to the signature of the given data.
 */
export async function sign(keyAlias: string, data: string): Promise<string> {
  return await LightsparkdevReactNativeCryptoModule.sign(keyAlias, data);
}

/**
 * @returns {Promise<number>} A promise that resolves to a random nonce unsigned 64-bit number.
 */
export async function getNonce(): Promise<number> {
  return await LightsparkdevReactNativeCryptoModule.getNonce();
}

/**
 * Generates a random bip39 mnemonic.
 * @param entropy An optional entropy string to use for generating the mnemonic.
 * @returns {Promise<Seed>} A promise that resolves to a random bip39 phrase.
 */
export async function generateMnemonic(entropy?: string): Promise<Mnemonic> {
  return await LightsparkdevReactNativeCryptoModule.generateMnemonic(entropy);
}

/**
 * Gets the seed from a mnemonic
 *
 * @param mnemonic The bip32 mnemonic to generate the seed.
 * @returns {Promise<Seed>} A promise that resolves to a seed.
 */
export async function getSeed(mnemonic: Mnemonic): Promise<Seed> {
  return await LightsparkdevReactNativeCryptoModule.getSeed(mnemonic);
}

/**
 * Derive the public key from a seed and a derivation path
 *
 * @param seed The master seed.
 * @param derivationPath The derivation path for the public key.
 * @returns {Promise<string>} A promise that resolves to a public key.
 */
export async function derivePublicKey(
  seed: Seed,
  derivationPath: string,
): Promise<string> {
  return await LightsparkdevReactNativeCryptoModule.derivePublicKey(
    seed,
    derivationPath,
  );
}

/**
 * Derives the private key from a seed and a derivation path, then sign a message with it.
 *
 * @param seed The master seed.
 * @param message The message to sign.
 * @param derivationPath The derivation path for the private key to use for signing.
 * @param addTweak An optional tweak to add to the private key.
 * @param multTweak An optional tweak to multiply the private key by.
 * @returns {Promise<Uint8Array>} A promise that resolves to a signature.
 */
export async function deriveKeyAndSign(
  seed: Seed,
  message: Uint8Array,
  derivationPath: string,
  addTweak?: Uint8Array,
  multTweak?: Uint8Array,
): Promise<Uint8Array> {
  const addTweakString = addTweak && b64encode(addTweak);
  const multTweakString = multTweak && b64encode(multTweak);
  return await LightsparkdevReactNativeCryptoModule.deriveKeyAndSign(
    seed,
    b64encode(message),
    derivationPath,
    addTweakString,
    multTweakString,
  );
}

/**
 * Performs a elliptic curve Diffie-Hellman key exchange.
 *
 * @param seed The master seed.
 * @param derivationPath The derivation path for the private key to use for the exchange.
 * @param publicKey The other party's public key in bech58 format.
 * @returns {Promise<Uint8Array>} A promise that resolves to the shared secret.
 */
export async function ecdh(
  seed: Seed,
  derivationPath: string,
  publicKey: string,
): Promise<Uint8Array> {
  const base64Result = await LightsparkdevReactNativeCryptoModule.ecdh(
    seed,
    derivationPath,
    publicKey,
  );
  return b64decode(base64Result);
}
